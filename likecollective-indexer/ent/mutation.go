// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"likecollective-indexer/ent/account"
	"likecollective-indexer/ent/evmevent"
	"likecollective-indexer/ent/nftclass"
	"likecollective-indexer/ent/predicate"
	"likecollective-indexer/ent/schema/typeutil"
	"likecollective-indexer/ent/staking"
	"likecollective-indexer/ent/stakingevent"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount      = "Account"
	TypeEVMEvent     = "EVMEvent"
	TypeNFTClass     = "NFTClass"
	TypeStaking      = "Staking"
	TypeStakingEvent = "StakingEvent"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	evm_address           *string
	staked_amount         *typeutil.Uint256
	pending_reward_amount *typeutil.Uint256
	claimed_reward_amount *typeutil.Uint256
	clearedFields         map[string]struct{}
	nft_classes           map[int]struct{}
	removednft_classes    map[int]struct{}
	clearednft_classes    bool
	staking_events        map[int]struct{}
	removedstaking_events map[int]struct{}
	clearedstaking_events bool
	stakings              map[int]struct{}
	removedstakings       map[int]struct{}
	clearedstakings       bool
	done                  bool
	oldValue              func(context.Context) (*Account, error)
	predicates            []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEvmAddress sets the "evm_address" field.
func (m *AccountMutation) SetEvmAddress(s string) {
	m.evm_address = &s
}

// EvmAddress returns the value of the "evm_address" field in the mutation.
func (m *AccountMutation) EvmAddress() (r string, exists bool) {
	v := m.evm_address
	if v == nil {
		return
	}
	return *v, true
}

// OldEvmAddress returns the old "evm_address" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldEvmAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvmAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvmAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvmAddress: %w", err)
	}
	return oldValue.EvmAddress, nil
}

// ResetEvmAddress resets all changes to the "evm_address" field.
func (m *AccountMutation) ResetEvmAddress() {
	m.evm_address = nil
}

// SetStakedAmount sets the "staked_amount" field.
func (m *AccountMutation) SetStakedAmount(t typeutil.Uint256) {
	m.staked_amount = &t
}

// StakedAmount returns the value of the "staked_amount" field in the mutation.
func (m *AccountMutation) StakedAmount() (r typeutil.Uint256, exists bool) {
	v := m.staked_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldStakedAmount returns the old "staked_amount" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldStakedAmount(ctx context.Context) (v typeutil.Uint256, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStakedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStakedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStakedAmount: %w", err)
	}
	return oldValue.StakedAmount, nil
}

// ResetStakedAmount resets all changes to the "staked_amount" field.
func (m *AccountMutation) ResetStakedAmount() {
	m.staked_amount = nil
}

// SetPendingRewardAmount sets the "pending_reward_amount" field.
func (m *AccountMutation) SetPendingRewardAmount(t typeutil.Uint256) {
	m.pending_reward_amount = &t
}

// PendingRewardAmount returns the value of the "pending_reward_amount" field in the mutation.
func (m *AccountMutation) PendingRewardAmount() (r typeutil.Uint256, exists bool) {
	v := m.pending_reward_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldPendingRewardAmount returns the old "pending_reward_amount" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPendingRewardAmount(ctx context.Context) (v typeutil.Uint256, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPendingRewardAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPendingRewardAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPendingRewardAmount: %w", err)
	}
	return oldValue.PendingRewardAmount, nil
}

// ResetPendingRewardAmount resets all changes to the "pending_reward_amount" field.
func (m *AccountMutation) ResetPendingRewardAmount() {
	m.pending_reward_amount = nil
}

// SetClaimedRewardAmount sets the "claimed_reward_amount" field.
func (m *AccountMutation) SetClaimedRewardAmount(t typeutil.Uint256) {
	m.claimed_reward_amount = &t
}

// ClaimedRewardAmount returns the value of the "claimed_reward_amount" field in the mutation.
func (m *AccountMutation) ClaimedRewardAmount() (r typeutil.Uint256, exists bool) {
	v := m.claimed_reward_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimedRewardAmount returns the old "claimed_reward_amount" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldClaimedRewardAmount(ctx context.Context) (v typeutil.Uint256, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimedRewardAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimedRewardAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimedRewardAmount: %w", err)
	}
	return oldValue.ClaimedRewardAmount, nil
}

// ResetClaimedRewardAmount resets all changes to the "claimed_reward_amount" field.
func (m *AccountMutation) ResetClaimedRewardAmount() {
	m.claimed_reward_amount = nil
}

// AddNftClassIDs adds the "nft_classes" edge to the NFTClass entity by ids.
func (m *AccountMutation) AddNftClassIDs(ids ...int) {
	if m.nft_classes == nil {
		m.nft_classes = make(map[int]struct{})
	}
	for i := range ids {
		m.nft_classes[ids[i]] = struct{}{}
	}
}

// ClearNftClasses clears the "nft_classes" edge to the NFTClass entity.
func (m *AccountMutation) ClearNftClasses() {
	m.clearednft_classes = true
}

// NftClassesCleared reports if the "nft_classes" edge to the NFTClass entity was cleared.
func (m *AccountMutation) NftClassesCleared() bool {
	return m.clearednft_classes
}

// RemoveNftClassIDs removes the "nft_classes" edge to the NFTClass entity by IDs.
func (m *AccountMutation) RemoveNftClassIDs(ids ...int) {
	if m.removednft_classes == nil {
		m.removednft_classes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.nft_classes, ids[i])
		m.removednft_classes[ids[i]] = struct{}{}
	}
}

// RemovedNftClasses returns the removed IDs of the "nft_classes" edge to the NFTClass entity.
func (m *AccountMutation) RemovedNftClassesIDs() (ids []int) {
	for id := range m.removednft_classes {
		ids = append(ids, id)
	}
	return
}

// NftClassesIDs returns the "nft_classes" edge IDs in the mutation.
func (m *AccountMutation) NftClassesIDs() (ids []int) {
	for id := range m.nft_classes {
		ids = append(ids, id)
	}
	return
}

// ResetNftClasses resets all changes to the "nft_classes" edge.
func (m *AccountMutation) ResetNftClasses() {
	m.nft_classes = nil
	m.clearednft_classes = false
	m.removednft_classes = nil
}

// AddStakingEventIDs adds the "staking_events" edge to the StakingEvent entity by ids.
func (m *AccountMutation) AddStakingEventIDs(ids ...int) {
	if m.staking_events == nil {
		m.staking_events = make(map[int]struct{})
	}
	for i := range ids {
		m.staking_events[ids[i]] = struct{}{}
	}
}

// ClearStakingEvents clears the "staking_events" edge to the StakingEvent entity.
func (m *AccountMutation) ClearStakingEvents() {
	m.clearedstaking_events = true
}

// StakingEventsCleared reports if the "staking_events" edge to the StakingEvent entity was cleared.
func (m *AccountMutation) StakingEventsCleared() bool {
	return m.clearedstaking_events
}

// RemoveStakingEventIDs removes the "staking_events" edge to the StakingEvent entity by IDs.
func (m *AccountMutation) RemoveStakingEventIDs(ids ...int) {
	if m.removedstaking_events == nil {
		m.removedstaking_events = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.staking_events, ids[i])
		m.removedstaking_events[ids[i]] = struct{}{}
	}
}

// RemovedStakingEvents returns the removed IDs of the "staking_events" edge to the StakingEvent entity.
func (m *AccountMutation) RemovedStakingEventsIDs() (ids []int) {
	for id := range m.removedstaking_events {
		ids = append(ids, id)
	}
	return
}

// StakingEventsIDs returns the "staking_events" edge IDs in the mutation.
func (m *AccountMutation) StakingEventsIDs() (ids []int) {
	for id := range m.staking_events {
		ids = append(ids, id)
	}
	return
}

// ResetStakingEvents resets all changes to the "staking_events" edge.
func (m *AccountMutation) ResetStakingEvents() {
	m.staking_events = nil
	m.clearedstaking_events = false
	m.removedstaking_events = nil
}

// AddStakingIDs adds the "stakings" edge to the Staking entity by ids.
func (m *AccountMutation) AddStakingIDs(ids ...int) {
	if m.stakings == nil {
		m.stakings = make(map[int]struct{})
	}
	for i := range ids {
		m.stakings[ids[i]] = struct{}{}
	}
}

// ClearStakings clears the "stakings" edge to the Staking entity.
func (m *AccountMutation) ClearStakings() {
	m.clearedstakings = true
}

// StakingsCleared reports if the "stakings" edge to the Staking entity was cleared.
func (m *AccountMutation) StakingsCleared() bool {
	return m.clearedstakings
}

// RemoveStakingIDs removes the "stakings" edge to the Staking entity by IDs.
func (m *AccountMutation) RemoveStakingIDs(ids ...int) {
	if m.removedstakings == nil {
		m.removedstakings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.stakings, ids[i])
		m.removedstakings[ids[i]] = struct{}{}
	}
}

// RemovedStakings returns the removed IDs of the "stakings" edge to the Staking entity.
func (m *AccountMutation) RemovedStakingsIDs() (ids []int) {
	for id := range m.removedstakings {
		ids = append(ids, id)
	}
	return
}

// StakingsIDs returns the "stakings" edge IDs in the mutation.
func (m *AccountMutation) StakingsIDs() (ids []int) {
	for id := range m.stakings {
		ids = append(ids, id)
	}
	return
}

// ResetStakings resets all changes to the "stakings" edge.
func (m *AccountMutation) ResetStakings() {
	m.stakings = nil
	m.clearedstakings = false
	m.removedstakings = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.evm_address != nil {
		fields = append(fields, account.FieldEvmAddress)
	}
	if m.staked_amount != nil {
		fields = append(fields, account.FieldStakedAmount)
	}
	if m.pending_reward_amount != nil {
		fields = append(fields, account.FieldPendingRewardAmount)
	}
	if m.claimed_reward_amount != nil {
		fields = append(fields, account.FieldClaimedRewardAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldEvmAddress:
		return m.EvmAddress()
	case account.FieldStakedAmount:
		return m.StakedAmount()
	case account.FieldPendingRewardAmount:
		return m.PendingRewardAmount()
	case account.FieldClaimedRewardAmount:
		return m.ClaimedRewardAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldEvmAddress:
		return m.OldEvmAddress(ctx)
	case account.FieldStakedAmount:
		return m.OldStakedAmount(ctx)
	case account.FieldPendingRewardAmount:
		return m.OldPendingRewardAmount(ctx)
	case account.FieldClaimedRewardAmount:
		return m.OldClaimedRewardAmount(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldEvmAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvmAddress(v)
		return nil
	case account.FieldStakedAmount:
		v, ok := value.(typeutil.Uint256)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStakedAmount(v)
		return nil
	case account.FieldPendingRewardAmount:
		v, ok := value.(typeutil.Uint256)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPendingRewardAmount(v)
		return nil
	case account.FieldClaimedRewardAmount:
		v, ok := value.(typeutil.Uint256)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimedRewardAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldEvmAddress:
		m.ResetEvmAddress()
		return nil
	case account.FieldStakedAmount:
		m.ResetStakedAmount()
		return nil
	case account.FieldPendingRewardAmount:
		m.ResetPendingRewardAmount()
		return nil
	case account.FieldClaimedRewardAmount:
		m.ResetClaimedRewardAmount()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.nft_classes != nil {
		edges = append(edges, account.EdgeNftClasses)
	}
	if m.staking_events != nil {
		edges = append(edges, account.EdgeStakingEvents)
	}
	if m.stakings != nil {
		edges = append(edges, account.EdgeStakings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeNftClasses:
		ids := make([]ent.Value, 0, len(m.nft_classes))
		for id := range m.nft_classes {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeStakingEvents:
		ids := make([]ent.Value, 0, len(m.staking_events))
		for id := range m.staking_events {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeStakings:
		ids := make([]ent.Value, 0, len(m.stakings))
		for id := range m.stakings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removednft_classes != nil {
		edges = append(edges, account.EdgeNftClasses)
	}
	if m.removedstaking_events != nil {
		edges = append(edges, account.EdgeStakingEvents)
	}
	if m.removedstakings != nil {
		edges = append(edges, account.EdgeStakings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeNftClasses:
		ids := make([]ent.Value, 0, len(m.removednft_classes))
		for id := range m.removednft_classes {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeStakingEvents:
		ids := make([]ent.Value, 0, len(m.removedstaking_events))
		for id := range m.removedstaking_events {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeStakings:
		ids := make([]ent.Value, 0, len(m.removedstakings))
		for id := range m.removedstakings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearednft_classes {
		edges = append(edges, account.EdgeNftClasses)
	}
	if m.clearedstaking_events {
		edges = append(edges, account.EdgeStakingEvents)
	}
	if m.clearedstakings {
		edges = append(edges, account.EdgeStakings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeNftClasses:
		return m.clearednft_classes
	case account.EdgeStakingEvents:
		return m.clearedstaking_events
	case account.EdgeStakings:
		return m.clearedstakings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeNftClasses:
		m.ResetNftClasses()
		return nil
	case account.EdgeStakingEvents:
		m.ResetStakingEvents()
		return nil
	case account.EdgeStakings:
		m.ResetStakings()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// EVMEventMutation represents an operation that mutates the EVMEvent nodes in the graph.
type EVMEventMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	transaction_hash     *string
	transaction_index    *uint
	addtransaction_index *int
	chain_id             *typeutil.Uint64
	addchain_id          *typeutil.Uint64
	block_hash           *string
	block_number         *typeutil.Uint64
	addblock_number      *typeutil.Uint64
	log_index            *uint
	addlog_index         *int
	address              *string
	topic0               *string
	topic0_hex           *string
	topic1               *string
	topic1_hex           *string
	topic2               *string
	topic2_hex           *string
	topic3               *string
	topic3_hex           *string
	data                 *string
	data_hex             *string
	removed              *bool
	status               *evmevent.Status
	name                 *string
	signature            *string
	indexed_params       *map[string]interface{}
	non_indexed_params   *map[string]interface{}
	failed_reason        *string
	timestamp            *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*EVMEvent, error)
	predicates           []predicate.EVMEvent
}

var _ ent.Mutation = (*EVMEventMutation)(nil)

// evmeventOption allows management of the mutation configuration using functional options.
type evmeventOption func(*EVMEventMutation)

// newEVMEventMutation creates new mutation for the EVMEvent entity.
func newEVMEventMutation(c config, op Op, opts ...evmeventOption) *EVMEventMutation {
	m := &EVMEventMutation{
		config:        c,
		op:            op,
		typ:           TypeEVMEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEVMEventID sets the ID field of the mutation.
func withEVMEventID(id int) evmeventOption {
	return func(m *EVMEventMutation) {
		var (
			err   error
			once  sync.Once
			value *EVMEvent
		)
		m.oldValue = func(ctx context.Context) (*EVMEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EVMEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEVMEvent sets the old EVMEvent of the mutation.
func withEVMEvent(node *EVMEvent) evmeventOption {
	return func(m *EVMEventMutation) {
		m.oldValue = func(context.Context) (*EVMEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EVMEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EVMEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EVMEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EVMEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EVMEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTransactionHash sets the "transaction_hash" field.
func (m *EVMEventMutation) SetTransactionHash(s string) {
	m.transaction_hash = &s
}

// TransactionHash returns the value of the "transaction_hash" field in the mutation.
func (m *EVMEventMutation) TransactionHash() (r string, exists bool) {
	v := m.transaction_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionHash returns the old "transaction_hash" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTransactionHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionHash: %w", err)
	}
	return oldValue.TransactionHash, nil
}

// ResetTransactionHash resets all changes to the "transaction_hash" field.
func (m *EVMEventMutation) ResetTransactionHash() {
	m.transaction_hash = nil
}

// SetTransactionIndex sets the "transaction_index" field.
func (m *EVMEventMutation) SetTransactionIndex(u uint) {
	m.transaction_index = &u
	m.addtransaction_index = nil
}

// TransactionIndex returns the value of the "transaction_index" field in the mutation.
func (m *EVMEventMutation) TransactionIndex() (r uint, exists bool) {
	v := m.transaction_index
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionIndex returns the old "transaction_index" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTransactionIndex(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionIndex: %w", err)
	}
	return oldValue.TransactionIndex, nil
}

// AddTransactionIndex adds u to the "transaction_index" field.
func (m *EVMEventMutation) AddTransactionIndex(u int) {
	if m.addtransaction_index != nil {
		*m.addtransaction_index += u
	} else {
		m.addtransaction_index = &u
	}
}

// AddedTransactionIndex returns the value that was added to the "transaction_index" field in this mutation.
func (m *EVMEventMutation) AddedTransactionIndex() (r int, exists bool) {
	v := m.addtransaction_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetTransactionIndex resets all changes to the "transaction_index" field.
func (m *EVMEventMutation) ResetTransactionIndex() {
	m.transaction_index = nil
	m.addtransaction_index = nil
}

// SetChainID sets the "chain_id" field.
func (m *EVMEventMutation) SetChainID(t typeutil.Uint64) {
	m.chain_id = &t
	m.addchain_id = nil
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *EVMEventMutation) ChainID() (r typeutil.Uint64, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldChainID(ctx context.Context) (v typeutil.Uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// AddChainID adds t to the "chain_id" field.
func (m *EVMEventMutation) AddChainID(t typeutil.Uint64) {
	if m.addchain_id != nil {
		*m.addchain_id += t
	} else {
		m.addchain_id = &t
	}
}

// AddedChainID returns the value that was added to the "chain_id" field in this mutation.
func (m *EVMEventMutation) AddedChainID() (r typeutil.Uint64, exists bool) {
	v := m.addchain_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *EVMEventMutation) ResetChainID() {
	m.chain_id = nil
	m.addchain_id = nil
}

// SetBlockHash sets the "block_hash" field.
func (m *EVMEventMutation) SetBlockHash(s string) {
	m.block_hash = &s
}

// BlockHash returns the value of the "block_hash" field in the mutation.
func (m *EVMEventMutation) BlockHash() (r string, exists bool) {
	v := m.block_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockHash returns the old "block_hash" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldBlockHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockHash: %w", err)
	}
	return oldValue.BlockHash, nil
}

// ResetBlockHash resets all changes to the "block_hash" field.
func (m *EVMEventMutation) ResetBlockHash() {
	m.block_hash = nil
}

// SetBlockNumber sets the "block_number" field.
func (m *EVMEventMutation) SetBlockNumber(t typeutil.Uint64) {
	m.block_number = &t
	m.addblock_number = nil
}

// BlockNumber returns the value of the "block_number" field in the mutation.
func (m *EVMEventMutation) BlockNumber() (r typeutil.Uint64, exists bool) {
	v := m.block_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockNumber returns the old "block_number" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldBlockNumber(ctx context.Context) (v typeutil.Uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockNumber: %w", err)
	}
	return oldValue.BlockNumber, nil
}

// AddBlockNumber adds t to the "block_number" field.
func (m *EVMEventMutation) AddBlockNumber(t typeutil.Uint64) {
	if m.addblock_number != nil {
		*m.addblock_number += t
	} else {
		m.addblock_number = &t
	}
}

// AddedBlockNumber returns the value that was added to the "block_number" field in this mutation.
func (m *EVMEventMutation) AddedBlockNumber() (r typeutil.Uint64, exists bool) {
	v := m.addblock_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockNumber resets all changes to the "block_number" field.
func (m *EVMEventMutation) ResetBlockNumber() {
	m.block_number = nil
	m.addblock_number = nil
}

// SetLogIndex sets the "log_index" field.
func (m *EVMEventMutation) SetLogIndex(u uint) {
	m.log_index = &u
	m.addlog_index = nil
}

// LogIndex returns the value of the "log_index" field in the mutation.
func (m *EVMEventMutation) LogIndex() (r uint, exists bool) {
	v := m.log_index
	if v == nil {
		return
	}
	return *v, true
}

// OldLogIndex returns the old "log_index" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldLogIndex(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogIndex: %w", err)
	}
	return oldValue.LogIndex, nil
}

// AddLogIndex adds u to the "log_index" field.
func (m *EVMEventMutation) AddLogIndex(u int) {
	if m.addlog_index != nil {
		*m.addlog_index += u
	} else {
		m.addlog_index = &u
	}
}

// AddedLogIndex returns the value that was added to the "log_index" field in this mutation.
func (m *EVMEventMutation) AddedLogIndex() (r int, exists bool) {
	v := m.addlog_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetLogIndex resets all changes to the "log_index" field.
func (m *EVMEventMutation) ResetLogIndex() {
	m.log_index = nil
	m.addlog_index = nil
}

// SetAddress sets the "address" field.
func (m *EVMEventMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *EVMEventMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *EVMEventMutation) ResetAddress() {
	m.address = nil
}

// SetTopic0 sets the "topic0" field.
func (m *EVMEventMutation) SetTopic0(s string) {
	m.topic0 = &s
}

// Topic0 returns the value of the "topic0" field in the mutation.
func (m *EVMEventMutation) Topic0() (r string, exists bool) {
	v := m.topic0
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic0 returns the old "topic0" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic0(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic0 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic0 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic0: %w", err)
	}
	return oldValue.Topic0, nil
}

// ResetTopic0 resets all changes to the "topic0" field.
func (m *EVMEventMutation) ResetTopic0() {
	m.topic0 = nil
}

// SetTopic0Hex sets the "topic0_hex" field.
func (m *EVMEventMutation) SetTopic0Hex(s string) {
	m.topic0_hex = &s
}

// Topic0Hex returns the value of the "topic0_hex" field in the mutation.
func (m *EVMEventMutation) Topic0Hex() (r string, exists bool) {
	v := m.topic0_hex
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic0Hex returns the old "topic0_hex" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic0Hex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic0Hex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic0Hex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic0Hex: %w", err)
	}
	return oldValue.Topic0Hex, nil
}

// ResetTopic0Hex resets all changes to the "topic0_hex" field.
func (m *EVMEventMutation) ResetTopic0Hex() {
	m.topic0_hex = nil
}

// SetTopic1 sets the "topic1" field.
func (m *EVMEventMutation) SetTopic1(s string) {
	m.topic1 = &s
}

// Topic1 returns the value of the "topic1" field in the mutation.
func (m *EVMEventMutation) Topic1() (r string, exists bool) {
	v := m.topic1
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic1 returns the old "topic1" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic1(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic1: %w", err)
	}
	return oldValue.Topic1, nil
}

// ClearTopic1 clears the value of the "topic1" field.
func (m *EVMEventMutation) ClearTopic1() {
	m.topic1 = nil
	m.clearedFields[evmevent.FieldTopic1] = struct{}{}
}

// Topic1Cleared returns if the "topic1" field was cleared in this mutation.
func (m *EVMEventMutation) Topic1Cleared() bool {
	_, ok := m.clearedFields[evmevent.FieldTopic1]
	return ok
}

// ResetTopic1 resets all changes to the "topic1" field.
func (m *EVMEventMutation) ResetTopic1() {
	m.topic1 = nil
	delete(m.clearedFields, evmevent.FieldTopic1)
}

// SetTopic1Hex sets the "topic1_hex" field.
func (m *EVMEventMutation) SetTopic1Hex(s string) {
	m.topic1_hex = &s
}

// Topic1Hex returns the value of the "topic1_hex" field in the mutation.
func (m *EVMEventMutation) Topic1Hex() (r string, exists bool) {
	v := m.topic1_hex
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic1Hex returns the old "topic1_hex" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic1Hex(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic1Hex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic1Hex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic1Hex: %w", err)
	}
	return oldValue.Topic1Hex, nil
}

// ClearTopic1Hex clears the value of the "topic1_hex" field.
func (m *EVMEventMutation) ClearTopic1Hex() {
	m.topic1_hex = nil
	m.clearedFields[evmevent.FieldTopic1Hex] = struct{}{}
}

// Topic1HexCleared returns if the "topic1_hex" field was cleared in this mutation.
func (m *EVMEventMutation) Topic1HexCleared() bool {
	_, ok := m.clearedFields[evmevent.FieldTopic1Hex]
	return ok
}

// ResetTopic1Hex resets all changes to the "topic1_hex" field.
func (m *EVMEventMutation) ResetTopic1Hex() {
	m.topic1_hex = nil
	delete(m.clearedFields, evmevent.FieldTopic1Hex)
}

// SetTopic2 sets the "topic2" field.
func (m *EVMEventMutation) SetTopic2(s string) {
	m.topic2 = &s
}

// Topic2 returns the value of the "topic2" field in the mutation.
func (m *EVMEventMutation) Topic2() (r string, exists bool) {
	v := m.topic2
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic2 returns the old "topic2" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic2(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic2: %w", err)
	}
	return oldValue.Topic2, nil
}

// ClearTopic2 clears the value of the "topic2" field.
func (m *EVMEventMutation) ClearTopic2() {
	m.topic2 = nil
	m.clearedFields[evmevent.FieldTopic2] = struct{}{}
}

// Topic2Cleared returns if the "topic2" field was cleared in this mutation.
func (m *EVMEventMutation) Topic2Cleared() bool {
	_, ok := m.clearedFields[evmevent.FieldTopic2]
	return ok
}

// ResetTopic2 resets all changes to the "topic2" field.
func (m *EVMEventMutation) ResetTopic2() {
	m.topic2 = nil
	delete(m.clearedFields, evmevent.FieldTopic2)
}

// SetTopic2Hex sets the "topic2_hex" field.
func (m *EVMEventMutation) SetTopic2Hex(s string) {
	m.topic2_hex = &s
}

// Topic2Hex returns the value of the "topic2_hex" field in the mutation.
func (m *EVMEventMutation) Topic2Hex() (r string, exists bool) {
	v := m.topic2_hex
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic2Hex returns the old "topic2_hex" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic2Hex(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic2Hex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic2Hex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic2Hex: %w", err)
	}
	return oldValue.Topic2Hex, nil
}

// ClearTopic2Hex clears the value of the "topic2_hex" field.
func (m *EVMEventMutation) ClearTopic2Hex() {
	m.topic2_hex = nil
	m.clearedFields[evmevent.FieldTopic2Hex] = struct{}{}
}

// Topic2HexCleared returns if the "topic2_hex" field was cleared in this mutation.
func (m *EVMEventMutation) Topic2HexCleared() bool {
	_, ok := m.clearedFields[evmevent.FieldTopic2Hex]
	return ok
}

// ResetTopic2Hex resets all changes to the "topic2_hex" field.
func (m *EVMEventMutation) ResetTopic2Hex() {
	m.topic2_hex = nil
	delete(m.clearedFields, evmevent.FieldTopic2Hex)
}

// SetTopic3 sets the "topic3" field.
func (m *EVMEventMutation) SetTopic3(s string) {
	m.topic3 = &s
}

// Topic3 returns the value of the "topic3" field in the mutation.
func (m *EVMEventMutation) Topic3() (r string, exists bool) {
	v := m.topic3
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic3 returns the old "topic3" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic3(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic3: %w", err)
	}
	return oldValue.Topic3, nil
}

// ClearTopic3 clears the value of the "topic3" field.
func (m *EVMEventMutation) ClearTopic3() {
	m.topic3 = nil
	m.clearedFields[evmevent.FieldTopic3] = struct{}{}
}

// Topic3Cleared returns if the "topic3" field was cleared in this mutation.
func (m *EVMEventMutation) Topic3Cleared() bool {
	_, ok := m.clearedFields[evmevent.FieldTopic3]
	return ok
}

// ResetTopic3 resets all changes to the "topic3" field.
func (m *EVMEventMutation) ResetTopic3() {
	m.topic3 = nil
	delete(m.clearedFields, evmevent.FieldTopic3)
}

// SetTopic3Hex sets the "topic3_hex" field.
func (m *EVMEventMutation) SetTopic3Hex(s string) {
	m.topic3_hex = &s
}

// Topic3Hex returns the value of the "topic3_hex" field in the mutation.
func (m *EVMEventMutation) Topic3Hex() (r string, exists bool) {
	v := m.topic3_hex
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic3Hex returns the old "topic3_hex" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic3Hex(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic3Hex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic3Hex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic3Hex: %w", err)
	}
	return oldValue.Topic3Hex, nil
}

// ClearTopic3Hex clears the value of the "topic3_hex" field.
func (m *EVMEventMutation) ClearTopic3Hex() {
	m.topic3_hex = nil
	m.clearedFields[evmevent.FieldTopic3Hex] = struct{}{}
}

// Topic3HexCleared returns if the "topic3_hex" field was cleared in this mutation.
func (m *EVMEventMutation) Topic3HexCleared() bool {
	_, ok := m.clearedFields[evmevent.FieldTopic3Hex]
	return ok
}

// ResetTopic3Hex resets all changes to the "topic3_hex" field.
func (m *EVMEventMutation) ResetTopic3Hex() {
	m.topic3_hex = nil
	delete(m.clearedFields, evmevent.FieldTopic3Hex)
}

// SetData sets the "data" field.
func (m *EVMEventMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *EVMEventMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldData(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *EVMEventMutation) ClearData() {
	m.data = nil
	m.clearedFields[evmevent.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *EVMEventMutation) DataCleared() bool {
	_, ok := m.clearedFields[evmevent.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *EVMEventMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, evmevent.FieldData)
}

// SetDataHex sets the "data_hex" field.
func (m *EVMEventMutation) SetDataHex(s string) {
	m.data_hex = &s
}

// DataHex returns the value of the "data_hex" field in the mutation.
func (m *EVMEventMutation) DataHex() (r string, exists bool) {
	v := m.data_hex
	if v == nil {
		return
	}
	return *v, true
}

// OldDataHex returns the old "data_hex" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldDataHex(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataHex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataHex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataHex: %w", err)
	}
	return oldValue.DataHex, nil
}

// ClearDataHex clears the value of the "data_hex" field.
func (m *EVMEventMutation) ClearDataHex() {
	m.data_hex = nil
	m.clearedFields[evmevent.FieldDataHex] = struct{}{}
}

// DataHexCleared returns if the "data_hex" field was cleared in this mutation.
func (m *EVMEventMutation) DataHexCleared() bool {
	_, ok := m.clearedFields[evmevent.FieldDataHex]
	return ok
}

// ResetDataHex resets all changes to the "data_hex" field.
func (m *EVMEventMutation) ResetDataHex() {
	m.data_hex = nil
	delete(m.clearedFields, evmevent.FieldDataHex)
}

// SetRemoved sets the "removed" field.
func (m *EVMEventMutation) SetRemoved(b bool) {
	m.removed = &b
}

// Removed returns the value of the "removed" field in the mutation.
func (m *EVMEventMutation) Removed() (r bool, exists bool) {
	v := m.removed
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoved returns the old "removed" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldRemoved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoved: %w", err)
	}
	return oldValue.Removed, nil
}

// ResetRemoved resets all changes to the "removed" field.
func (m *EVMEventMutation) ResetRemoved() {
	m.removed = nil
}

// SetStatus sets the "status" field.
func (m *EVMEventMutation) SetStatus(e evmevent.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EVMEventMutation) Status() (r evmevent.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldStatus(ctx context.Context) (v evmevent.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EVMEventMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *EVMEventMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EVMEventMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EVMEventMutation) ResetName() {
	m.name = nil
}

// SetSignature sets the "signature" field.
func (m *EVMEventMutation) SetSignature(s string) {
	m.signature = &s
}

// Signature returns the value of the "signature" field in the mutation.
func (m *EVMEventMutation) Signature() (r string, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldSignature(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ResetSignature resets all changes to the "signature" field.
func (m *EVMEventMutation) ResetSignature() {
	m.signature = nil
}

// SetIndexedParams sets the "indexed_params" field.
func (m *EVMEventMutation) SetIndexedParams(value map[string]interface{}) {
	m.indexed_params = &value
}

// IndexedParams returns the value of the "indexed_params" field in the mutation.
func (m *EVMEventMutation) IndexedParams() (r map[string]interface{}, exists bool) {
	v := m.indexed_params
	if v == nil {
		return
	}
	return *v, true
}

// OldIndexedParams returns the old "indexed_params" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldIndexedParams(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndexedParams is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndexedParams requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndexedParams: %w", err)
	}
	return oldValue.IndexedParams, nil
}

// ResetIndexedParams resets all changes to the "indexed_params" field.
func (m *EVMEventMutation) ResetIndexedParams() {
	m.indexed_params = nil
}

// SetNonIndexedParams sets the "non_indexed_params" field.
func (m *EVMEventMutation) SetNonIndexedParams(value map[string]interface{}) {
	m.non_indexed_params = &value
}

// NonIndexedParams returns the value of the "non_indexed_params" field in the mutation.
func (m *EVMEventMutation) NonIndexedParams() (r map[string]interface{}, exists bool) {
	v := m.non_indexed_params
	if v == nil {
		return
	}
	return *v, true
}

// OldNonIndexedParams returns the old "non_indexed_params" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldNonIndexedParams(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonIndexedParams is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonIndexedParams requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonIndexedParams: %w", err)
	}
	return oldValue.NonIndexedParams, nil
}

// ResetNonIndexedParams resets all changes to the "non_indexed_params" field.
func (m *EVMEventMutation) ResetNonIndexedParams() {
	m.non_indexed_params = nil
}

// SetFailedReason sets the "failed_reason" field.
func (m *EVMEventMutation) SetFailedReason(s string) {
	m.failed_reason = &s
}

// FailedReason returns the value of the "failed_reason" field in the mutation.
func (m *EVMEventMutation) FailedReason() (r string, exists bool) {
	v := m.failed_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailedReason returns the old "failed_reason" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldFailedReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailedReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailedReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailedReason: %w", err)
	}
	return oldValue.FailedReason, nil
}

// ClearFailedReason clears the value of the "failed_reason" field.
func (m *EVMEventMutation) ClearFailedReason() {
	m.failed_reason = nil
	m.clearedFields[evmevent.FieldFailedReason] = struct{}{}
}

// FailedReasonCleared returns if the "failed_reason" field was cleared in this mutation.
func (m *EVMEventMutation) FailedReasonCleared() bool {
	_, ok := m.clearedFields[evmevent.FieldFailedReason]
	return ok
}

// ResetFailedReason resets all changes to the "failed_reason" field.
func (m *EVMEventMutation) ResetFailedReason() {
	m.failed_reason = nil
	delete(m.clearedFields, evmevent.FieldFailedReason)
}

// SetTimestamp sets the "timestamp" field.
func (m *EVMEventMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *EVMEventMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *EVMEventMutation) ResetTimestamp() {
	m.timestamp = nil
}

// Where appends a list predicates to the EVMEventMutation builder.
func (m *EVMEventMutation) Where(ps ...predicate.EVMEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EVMEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EVMEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EVMEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EVMEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EVMEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EVMEvent).
func (m *EVMEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EVMEventMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.transaction_hash != nil {
		fields = append(fields, evmevent.FieldTransactionHash)
	}
	if m.transaction_index != nil {
		fields = append(fields, evmevent.FieldTransactionIndex)
	}
	if m.chain_id != nil {
		fields = append(fields, evmevent.FieldChainID)
	}
	if m.block_hash != nil {
		fields = append(fields, evmevent.FieldBlockHash)
	}
	if m.block_number != nil {
		fields = append(fields, evmevent.FieldBlockNumber)
	}
	if m.log_index != nil {
		fields = append(fields, evmevent.FieldLogIndex)
	}
	if m.address != nil {
		fields = append(fields, evmevent.FieldAddress)
	}
	if m.topic0 != nil {
		fields = append(fields, evmevent.FieldTopic0)
	}
	if m.topic0_hex != nil {
		fields = append(fields, evmevent.FieldTopic0Hex)
	}
	if m.topic1 != nil {
		fields = append(fields, evmevent.FieldTopic1)
	}
	if m.topic1_hex != nil {
		fields = append(fields, evmevent.FieldTopic1Hex)
	}
	if m.topic2 != nil {
		fields = append(fields, evmevent.FieldTopic2)
	}
	if m.topic2_hex != nil {
		fields = append(fields, evmevent.FieldTopic2Hex)
	}
	if m.topic3 != nil {
		fields = append(fields, evmevent.FieldTopic3)
	}
	if m.topic3_hex != nil {
		fields = append(fields, evmevent.FieldTopic3Hex)
	}
	if m.data != nil {
		fields = append(fields, evmevent.FieldData)
	}
	if m.data_hex != nil {
		fields = append(fields, evmevent.FieldDataHex)
	}
	if m.removed != nil {
		fields = append(fields, evmevent.FieldRemoved)
	}
	if m.status != nil {
		fields = append(fields, evmevent.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, evmevent.FieldName)
	}
	if m.signature != nil {
		fields = append(fields, evmevent.FieldSignature)
	}
	if m.indexed_params != nil {
		fields = append(fields, evmevent.FieldIndexedParams)
	}
	if m.non_indexed_params != nil {
		fields = append(fields, evmevent.FieldNonIndexedParams)
	}
	if m.failed_reason != nil {
		fields = append(fields, evmevent.FieldFailedReason)
	}
	if m.timestamp != nil {
		fields = append(fields, evmevent.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EVMEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case evmevent.FieldTransactionHash:
		return m.TransactionHash()
	case evmevent.FieldTransactionIndex:
		return m.TransactionIndex()
	case evmevent.FieldChainID:
		return m.ChainID()
	case evmevent.FieldBlockHash:
		return m.BlockHash()
	case evmevent.FieldBlockNumber:
		return m.BlockNumber()
	case evmevent.FieldLogIndex:
		return m.LogIndex()
	case evmevent.FieldAddress:
		return m.Address()
	case evmevent.FieldTopic0:
		return m.Topic0()
	case evmevent.FieldTopic0Hex:
		return m.Topic0Hex()
	case evmevent.FieldTopic1:
		return m.Topic1()
	case evmevent.FieldTopic1Hex:
		return m.Topic1Hex()
	case evmevent.FieldTopic2:
		return m.Topic2()
	case evmevent.FieldTopic2Hex:
		return m.Topic2Hex()
	case evmevent.FieldTopic3:
		return m.Topic3()
	case evmevent.FieldTopic3Hex:
		return m.Topic3Hex()
	case evmevent.FieldData:
		return m.Data()
	case evmevent.FieldDataHex:
		return m.DataHex()
	case evmevent.FieldRemoved:
		return m.Removed()
	case evmevent.FieldStatus:
		return m.Status()
	case evmevent.FieldName:
		return m.Name()
	case evmevent.FieldSignature:
		return m.Signature()
	case evmevent.FieldIndexedParams:
		return m.IndexedParams()
	case evmevent.FieldNonIndexedParams:
		return m.NonIndexedParams()
	case evmevent.FieldFailedReason:
		return m.FailedReason()
	case evmevent.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EVMEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case evmevent.FieldTransactionHash:
		return m.OldTransactionHash(ctx)
	case evmevent.FieldTransactionIndex:
		return m.OldTransactionIndex(ctx)
	case evmevent.FieldChainID:
		return m.OldChainID(ctx)
	case evmevent.FieldBlockHash:
		return m.OldBlockHash(ctx)
	case evmevent.FieldBlockNumber:
		return m.OldBlockNumber(ctx)
	case evmevent.FieldLogIndex:
		return m.OldLogIndex(ctx)
	case evmevent.FieldAddress:
		return m.OldAddress(ctx)
	case evmevent.FieldTopic0:
		return m.OldTopic0(ctx)
	case evmevent.FieldTopic0Hex:
		return m.OldTopic0Hex(ctx)
	case evmevent.FieldTopic1:
		return m.OldTopic1(ctx)
	case evmevent.FieldTopic1Hex:
		return m.OldTopic1Hex(ctx)
	case evmevent.FieldTopic2:
		return m.OldTopic2(ctx)
	case evmevent.FieldTopic2Hex:
		return m.OldTopic2Hex(ctx)
	case evmevent.FieldTopic3:
		return m.OldTopic3(ctx)
	case evmevent.FieldTopic3Hex:
		return m.OldTopic3Hex(ctx)
	case evmevent.FieldData:
		return m.OldData(ctx)
	case evmevent.FieldDataHex:
		return m.OldDataHex(ctx)
	case evmevent.FieldRemoved:
		return m.OldRemoved(ctx)
	case evmevent.FieldStatus:
		return m.OldStatus(ctx)
	case evmevent.FieldName:
		return m.OldName(ctx)
	case evmevent.FieldSignature:
		return m.OldSignature(ctx)
	case evmevent.FieldIndexedParams:
		return m.OldIndexedParams(ctx)
	case evmevent.FieldNonIndexedParams:
		return m.OldNonIndexedParams(ctx)
	case evmevent.FieldFailedReason:
		return m.OldFailedReason(ctx)
	case evmevent.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown EVMEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EVMEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case evmevent.FieldTransactionHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionHash(v)
		return nil
	case evmevent.FieldTransactionIndex:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionIndex(v)
		return nil
	case evmevent.FieldChainID:
		v, ok := value.(typeutil.Uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	case evmevent.FieldBlockHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockHash(v)
		return nil
	case evmevent.FieldBlockNumber:
		v, ok := value.(typeutil.Uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockNumber(v)
		return nil
	case evmevent.FieldLogIndex:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogIndex(v)
		return nil
	case evmevent.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case evmevent.FieldTopic0:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic0(v)
		return nil
	case evmevent.FieldTopic0Hex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic0Hex(v)
		return nil
	case evmevent.FieldTopic1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic1(v)
		return nil
	case evmevent.FieldTopic1Hex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic1Hex(v)
		return nil
	case evmevent.FieldTopic2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic2(v)
		return nil
	case evmevent.FieldTopic2Hex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic2Hex(v)
		return nil
	case evmevent.FieldTopic3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic3(v)
		return nil
	case evmevent.FieldTopic3Hex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic3Hex(v)
		return nil
	case evmevent.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case evmevent.FieldDataHex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataHex(v)
		return nil
	case evmevent.FieldRemoved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoved(v)
		return nil
	case evmevent.FieldStatus:
		v, ok := value.(evmevent.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case evmevent.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case evmevent.FieldSignature:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case evmevent.FieldIndexedParams:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndexedParams(v)
		return nil
	case evmevent.FieldNonIndexedParams:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonIndexedParams(v)
		return nil
	case evmevent.FieldFailedReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailedReason(v)
		return nil
	case evmevent.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown EVMEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EVMEventMutation) AddedFields() []string {
	var fields []string
	if m.addtransaction_index != nil {
		fields = append(fields, evmevent.FieldTransactionIndex)
	}
	if m.addchain_id != nil {
		fields = append(fields, evmevent.FieldChainID)
	}
	if m.addblock_number != nil {
		fields = append(fields, evmevent.FieldBlockNumber)
	}
	if m.addlog_index != nil {
		fields = append(fields, evmevent.FieldLogIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EVMEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case evmevent.FieldTransactionIndex:
		return m.AddedTransactionIndex()
	case evmevent.FieldChainID:
		return m.AddedChainID()
	case evmevent.FieldBlockNumber:
		return m.AddedBlockNumber()
	case evmevent.FieldLogIndex:
		return m.AddedLogIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EVMEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case evmevent.FieldTransactionIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTransactionIndex(v)
		return nil
	case evmevent.FieldChainID:
		v, ok := value.(typeutil.Uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChainID(v)
		return nil
	case evmevent.FieldBlockNumber:
		v, ok := value.(typeutil.Uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockNumber(v)
		return nil
	case evmevent.FieldLogIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLogIndex(v)
		return nil
	}
	return fmt.Errorf("unknown EVMEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EVMEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(evmevent.FieldTopic1) {
		fields = append(fields, evmevent.FieldTopic1)
	}
	if m.FieldCleared(evmevent.FieldTopic1Hex) {
		fields = append(fields, evmevent.FieldTopic1Hex)
	}
	if m.FieldCleared(evmevent.FieldTopic2) {
		fields = append(fields, evmevent.FieldTopic2)
	}
	if m.FieldCleared(evmevent.FieldTopic2Hex) {
		fields = append(fields, evmevent.FieldTopic2Hex)
	}
	if m.FieldCleared(evmevent.FieldTopic3) {
		fields = append(fields, evmevent.FieldTopic3)
	}
	if m.FieldCleared(evmevent.FieldTopic3Hex) {
		fields = append(fields, evmevent.FieldTopic3Hex)
	}
	if m.FieldCleared(evmevent.FieldData) {
		fields = append(fields, evmevent.FieldData)
	}
	if m.FieldCleared(evmevent.FieldDataHex) {
		fields = append(fields, evmevent.FieldDataHex)
	}
	if m.FieldCleared(evmevent.FieldFailedReason) {
		fields = append(fields, evmevent.FieldFailedReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EVMEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EVMEventMutation) ClearField(name string) error {
	switch name {
	case evmevent.FieldTopic1:
		m.ClearTopic1()
		return nil
	case evmevent.FieldTopic1Hex:
		m.ClearTopic1Hex()
		return nil
	case evmevent.FieldTopic2:
		m.ClearTopic2()
		return nil
	case evmevent.FieldTopic2Hex:
		m.ClearTopic2Hex()
		return nil
	case evmevent.FieldTopic3:
		m.ClearTopic3()
		return nil
	case evmevent.FieldTopic3Hex:
		m.ClearTopic3Hex()
		return nil
	case evmevent.FieldData:
		m.ClearData()
		return nil
	case evmevent.FieldDataHex:
		m.ClearDataHex()
		return nil
	case evmevent.FieldFailedReason:
		m.ClearFailedReason()
		return nil
	}
	return fmt.Errorf("unknown EVMEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EVMEventMutation) ResetField(name string) error {
	switch name {
	case evmevent.FieldTransactionHash:
		m.ResetTransactionHash()
		return nil
	case evmevent.FieldTransactionIndex:
		m.ResetTransactionIndex()
		return nil
	case evmevent.FieldChainID:
		m.ResetChainID()
		return nil
	case evmevent.FieldBlockHash:
		m.ResetBlockHash()
		return nil
	case evmevent.FieldBlockNumber:
		m.ResetBlockNumber()
		return nil
	case evmevent.FieldLogIndex:
		m.ResetLogIndex()
		return nil
	case evmevent.FieldAddress:
		m.ResetAddress()
		return nil
	case evmevent.FieldTopic0:
		m.ResetTopic0()
		return nil
	case evmevent.FieldTopic0Hex:
		m.ResetTopic0Hex()
		return nil
	case evmevent.FieldTopic1:
		m.ResetTopic1()
		return nil
	case evmevent.FieldTopic1Hex:
		m.ResetTopic1Hex()
		return nil
	case evmevent.FieldTopic2:
		m.ResetTopic2()
		return nil
	case evmevent.FieldTopic2Hex:
		m.ResetTopic2Hex()
		return nil
	case evmevent.FieldTopic3:
		m.ResetTopic3()
		return nil
	case evmevent.FieldTopic3Hex:
		m.ResetTopic3Hex()
		return nil
	case evmevent.FieldData:
		m.ResetData()
		return nil
	case evmevent.FieldDataHex:
		m.ResetDataHex()
		return nil
	case evmevent.FieldRemoved:
		m.ResetRemoved()
		return nil
	case evmevent.FieldStatus:
		m.ResetStatus()
		return nil
	case evmevent.FieldName:
		m.ResetName()
		return nil
	case evmevent.FieldSignature:
		m.ResetSignature()
		return nil
	case evmevent.FieldIndexedParams:
		m.ResetIndexedParams()
		return nil
	case evmevent.FieldNonIndexedParams:
		m.ResetNonIndexedParams()
		return nil
	case evmevent.FieldFailedReason:
		m.ResetFailedReason()
		return nil
	case evmevent.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown EVMEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EVMEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EVMEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EVMEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EVMEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EVMEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EVMEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EVMEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EVMEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EVMEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EVMEvent edge %s", name)
}

// NFTClassMutation represents an operation that mutates the NFTClass nodes in the graph.
type NFTClassMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	address               *string
	staked_amount         *typeutil.Uint256
	last_staked_at        *time.Time
	number_of_stakers     *uint64
	addnumber_of_stakers  *int64
	clearedFields         map[string]struct{}
	accounts              map[int]struct{}
	removedaccounts       map[int]struct{}
	clearedaccounts       bool
	staking_events        map[int]struct{}
	removedstaking_events map[int]struct{}
	clearedstaking_events bool
	stakings              map[int]struct{}
	removedstakings       map[int]struct{}
	clearedstakings       bool
	done                  bool
	oldValue              func(context.Context) (*NFTClass, error)
	predicates            []predicate.NFTClass
}

var _ ent.Mutation = (*NFTClassMutation)(nil)

// nftclassOption allows management of the mutation configuration using functional options.
type nftclassOption func(*NFTClassMutation)

// newNFTClassMutation creates new mutation for the NFTClass entity.
func newNFTClassMutation(c config, op Op, opts ...nftclassOption) *NFTClassMutation {
	m := &NFTClassMutation{
		config:        c,
		op:            op,
		typ:           TypeNFTClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNFTClassID sets the ID field of the mutation.
func withNFTClassID(id int) nftclassOption {
	return func(m *NFTClassMutation) {
		var (
			err   error
			once  sync.Once
			value *NFTClass
		)
		m.oldValue = func(ctx context.Context) (*NFTClass, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NFTClass.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNFTClass sets the old NFTClass of the mutation.
func withNFTClass(node *NFTClass) nftclassOption {
	return func(m *NFTClassMutation) {
		m.oldValue = func(context.Context) (*NFTClass, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NFTClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NFTClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NFTClassMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NFTClassMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NFTClass.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAddress sets the "address" field.
func (m *NFTClassMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *NFTClassMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *NFTClassMutation) ResetAddress() {
	m.address = nil
}

// SetStakedAmount sets the "staked_amount" field.
func (m *NFTClassMutation) SetStakedAmount(t typeutil.Uint256) {
	m.staked_amount = &t
}

// StakedAmount returns the value of the "staked_amount" field in the mutation.
func (m *NFTClassMutation) StakedAmount() (r typeutil.Uint256, exists bool) {
	v := m.staked_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldStakedAmount returns the old "staked_amount" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldStakedAmount(ctx context.Context) (v typeutil.Uint256, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStakedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStakedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStakedAmount: %w", err)
	}
	return oldValue.StakedAmount, nil
}

// ResetStakedAmount resets all changes to the "staked_amount" field.
func (m *NFTClassMutation) ResetStakedAmount() {
	m.staked_amount = nil
}

// SetLastStakedAt sets the "last_staked_at" field.
func (m *NFTClassMutation) SetLastStakedAt(t time.Time) {
	m.last_staked_at = &t
}

// LastStakedAt returns the value of the "last_staked_at" field in the mutation.
func (m *NFTClassMutation) LastStakedAt() (r time.Time, exists bool) {
	v := m.last_staked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastStakedAt returns the old "last_staked_at" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldLastStakedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastStakedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastStakedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastStakedAt: %w", err)
	}
	return oldValue.LastStakedAt, nil
}

// ResetLastStakedAt resets all changes to the "last_staked_at" field.
func (m *NFTClassMutation) ResetLastStakedAt() {
	m.last_staked_at = nil
}

// SetNumberOfStakers sets the "number_of_stakers" field.
func (m *NFTClassMutation) SetNumberOfStakers(u uint64) {
	m.number_of_stakers = &u
	m.addnumber_of_stakers = nil
}

// NumberOfStakers returns the value of the "number_of_stakers" field in the mutation.
func (m *NFTClassMutation) NumberOfStakers() (r uint64, exists bool) {
	v := m.number_of_stakers
	if v == nil {
		return
	}
	return *v, true
}

// OldNumberOfStakers returns the old "number_of_stakers" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldNumberOfStakers(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumberOfStakers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumberOfStakers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumberOfStakers: %w", err)
	}
	return oldValue.NumberOfStakers, nil
}

// AddNumberOfStakers adds u to the "number_of_stakers" field.
func (m *NFTClassMutation) AddNumberOfStakers(u int64) {
	if m.addnumber_of_stakers != nil {
		*m.addnumber_of_stakers += u
	} else {
		m.addnumber_of_stakers = &u
	}
}

// AddedNumberOfStakers returns the value that was added to the "number_of_stakers" field in this mutation.
func (m *NFTClassMutation) AddedNumberOfStakers() (r int64, exists bool) {
	v := m.addnumber_of_stakers
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumberOfStakers resets all changes to the "number_of_stakers" field.
func (m *NFTClassMutation) ResetNumberOfStakers() {
	m.number_of_stakers = nil
	m.addnumber_of_stakers = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *NFTClassMutation) AddAccountIDs(ids ...int) {
	if m.accounts == nil {
		m.accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *NFTClassMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *NFTClassMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *NFTClassMutation) RemoveAccountIDs(ids ...int) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *NFTClassMutation) RemovedAccountsIDs() (ids []int) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *NFTClassMutation) AccountsIDs() (ids []int) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *NFTClassMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddStakingEventIDs adds the "staking_events" edge to the StakingEvent entity by ids.
func (m *NFTClassMutation) AddStakingEventIDs(ids ...int) {
	if m.staking_events == nil {
		m.staking_events = make(map[int]struct{})
	}
	for i := range ids {
		m.staking_events[ids[i]] = struct{}{}
	}
}

// ClearStakingEvents clears the "staking_events" edge to the StakingEvent entity.
func (m *NFTClassMutation) ClearStakingEvents() {
	m.clearedstaking_events = true
}

// StakingEventsCleared reports if the "staking_events" edge to the StakingEvent entity was cleared.
func (m *NFTClassMutation) StakingEventsCleared() bool {
	return m.clearedstaking_events
}

// RemoveStakingEventIDs removes the "staking_events" edge to the StakingEvent entity by IDs.
func (m *NFTClassMutation) RemoveStakingEventIDs(ids ...int) {
	if m.removedstaking_events == nil {
		m.removedstaking_events = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.staking_events, ids[i])
		m.removedstaking_events[ids[i]] = struct{}{}
	}
}

// RemovedStakingEvents returns the removed IDs of the "staking_events" edge to the StakingEvent entity.
func (m *NFTClassMutation) RemovedStakingEventsIDs() (ids []int) {
	for id := range m.removedstaking_events {
		ids = append(ids, id)
	}
	return
}

// StakingEventsIDs returns the "staking_events" edge IDs in the mutation.
func (m *NFTClassMutation) StakingEventsIDs() (ids []int) {
	for id := range m.staking_events {
		ids = append(ids, id)
	}
	return
}

// ResetStakingEvents resets all changes to the "staking_events" edge.
func (m *NFTClassMutation) ResetStakingEvents() {
	m.staking_events = nil
	m.clearedstaking_events = false
	m.removedstaking_events = nil
}

// AddStakingIDs adds the "stakings" edge to the Staking entity by ids.
func (m *NFTClassMutation) AddStakingIDs(ids ...int) {
	if m.stakings == nil {
		m.stakings = make(map[int]struct{})
	}
	for i := range ids {
		m.stakings[ids[i]] = struct{}{}
	}
}

// ClearStakings clears the "stakings" edge to the Staking entity.
func (m *NFTClassMutation) ClearStakings() {
	m.clearedstakings = true
}

// StakingsCleared reports if the "stakings" edge to the Staking entity was cleared.
func (m *NFTClassMutation) StakingsCleared() bool {
	return m.clearedstakings
}

// RemoveStakingIDs removes the "stakings" edge to the Staking entity by IDs.
func (m *NFTClassMutation) RemoveStakingIDs(ids ...int) {
	if m.removedstakings == nil {
		m.removedstakings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.stakings, ids[i])
		m.removedstakings[ids[i]] = struct{}{}
	}
}

// RemovedStakings returns the removed IDs of the "stakings" edge to the Staking entity.
func (m *NFTClassMutation) RemovedStakingsIDs() (ids []int) {
	for id := range m.removedstakings {
		ids = append(ids, id)
	}
	return
}

// StakingsIDs returns the "stakings" edge IDs in the mutation.
func (m *NFTClassMutation) StakingsIDs() (ids []int) {
	for id := range m.stakings {
		ids = append(ids, id)
	}
	return
}

// ResetStakings resets all changes to the "stakings" edge.
func (m *NFTClassMutation) ResetStakings() {
	m.stakings = nil
	m.clearedstakings = false
	m.removedstakings = nil
}

// Where appends a list predicates to the NFTClassMutation builder.
func (m *NFTClassMutation) Where(ps ...predicate.NFTClass) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NFTClassMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NFTClassMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NFTClass, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NFTClassMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NFTClassMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NFTClass).
func (m *NFTClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NFTClassMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.address != nil {
		fields = append(fields, nftclass.FieldAddress)
	}
	if m.staked_amount != nil {
		fields = append(fields, nftclass.FieldStakedAmount)
	}
	if m.last_staked_at != nil {
		fields = append(fields, nftclass.FieldLastStakedAt)
	}
	if m.number_of_stakers != nil {
		fields = append(fields, nftclass.FieldNumberOfStakers)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NFTClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nftclass.FieldAddress:
		return m.Address()
	case nftclass.FieldStakedAmount:
		return m.StakedAmount()
	case nftclass.FieldLastStakedAt:
		return m.LastStakedAt()
	case nftclass.FieldNumberOfStakers:
		return m.NumberOfStakers()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NFTClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nftclass.FieldAddress:
		return m.OldAddress(ctx)
	case nftclass.FieldStakedAmount:
		return m.OldStakedAmount(ctx)
	case nftclass.FieldLastStakedAt:
		return m.OldLastStakedAt(ctx)
	case nftclass.FieldNumberOfStakers:
		return m.OldNumberOfStakers(ctx)
	}
	return nil, fmt.Errorf("unknown NFTClass field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NFTClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nftclass.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case nftclass.FieldStakedAmount:
		v, ok := value.(typeutil.Uint256)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStakedAmount(v)
		return nil
	case nftclass.FieldLastStakedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastStakedAt(v)
		return nil
	case nftclass.FieldNumberOfStakers:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumberOfStakers(v)
		return nil
	}
	return fmt.Errorf("unknown NFTClass field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NFTClassMutation) AddedFields() []string {
	var fields []string
	if m.addnumber_of_stakers != nil {
		fields = append(fields, nftclass.FieldNumberOfStakers)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NFTClassMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case nftclass.FieldNumberOfStakers:
		return m.AddedNumberOfStakers()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NFTClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	case nftclass.FieldNumberOfStakers:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumberOfStakers(v)
		return nil
	}
	return fmt.Errorf("unknown NFTClass numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NFTClassMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NFTClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NFTClassMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NFTClass nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NFTClassMutation) ResetField(name string) error {
	switch name {
	case nftclass.FieldAddress:
		m.ResetAddress()
		return nil
	case nftclass.FieldStakedAmount:
		m.ResetStakedAmount()
		return nil
	case nftclass.FieldLastStakedAt:
		m.ResetLastStakedAt()
		return nil
	case nftclass.FieldNumberOfStakers:
		m.ResetNumberOfStakers()
		return nil
	}
	return fmt.Errorf("unknown NFTClass field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NFTClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.accounts != nil {
		edges = append(edges, nftclass.EdgeAccounts)
	}
	if m.staking_events != nil {
		edges = append(edges, nftclass.EdgeStakingEvents)
	}
	if m.stakings != nil {
		edges = append(edges, nftclass.EdgeStakings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NFTClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nftclass.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case nftclass.EdgeStakingEvents:
		ids := make([]ent.Value, 0, len(m.staking_events))
		for id := range m.staking_events {
			ids = append(ids, id)
		}
		return ids
	case nftclass.EdgeStakings:
		ids := make([]ent.Value, 0, len(m.stakings))
		for id := range m.stakings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NFTClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedaccounts != nil {
		edges = append(edges, nftclass.EdgeAccounts)
	}
	if m.removedstaking_events != nil {
		edges = append(edges, nftclass.EdgeStakingEvents)
	}
	if m.removedstakings != nil {
		edges = append(edges, nftclass.EdgeStakings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NFTClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nftclass.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case nftclass.EdgeStakingEvents:
		ids := make([]ent.Value, 0, len(m.removedstaking_events))
		for id := range m.removedstaking_events {
			ids = append(ids, id)
		}
		return ids
	case nftclass.EdgeStakings:
		ids := make([]ent.Value, 0, len(m.removedstakings))
		for id := range m.removedstakings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NFTClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedaccounts {
		edges = append(edges, nftclass.EdgeAccounts)
	}
	if m.clearedstaking_events {
		edges = append(edges, nftclass.EdgeStakingEvents)
	}
	if m.clearedstakings {
		edges = append(edges, nftclass.EdgeStakings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NFTClassMutation) EdgeCleared(name string) bool {
	switch name {
	case nftclass.EdgeAccounts:
		return m.clearedaccounts
	case nftclass.EdgeStakingEvents:
		return m.clearedstaking_events
	case nftclass.EdgeStakings:
		return m.clearedstakings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NFTClassMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NFTClass unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NFTClassMutation) ResetEdge(name string) error {
	switch name {
	case nftclass.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case nftclass.EdgeStakingEvents:
		m.ResetStakingEvents()
		return nil
	case nftclass.EdgeStakings:
		m.ResetStakings()
		return nil
	}
	return fmt.Errorf("unknown NFTClass edge %s", name)
}

// StakingMutation represents an operation that mutates the Staking nodes in the graph.
type StakingMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	pool_share            *string
	staked_amount         *typeutil.Uint256
	pending_reward_amount *typeutil.Uint256
	claimed_reward_amount *typeutil.Uint256
	clearedFields         map[string]struct{}
	account               *int
	clearedaccount        bool
	nft_class             *int
	clearednft_class      bool
	done                  bool
	oldValue              func(context.Context) (*Staking, error)
	predicates            []predicate.Staking
}

var _ ent.Mutation = (*StakingMutation)(nil)

// stakingOption allows management of the mutation configuration using functional options.
type stakingOption func(*StakingMutation)

// newStakingMutation creates new mutation for the Staking entity.
func newStakingMutation(c config, op Op, opts ...stakingOption) *StakingMutation {
	m := &StakingMutation{
		config:        c,
		op:            op,
		typ:           TypeStaking,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStakingID sets the ID field of the mutation.
func withStakingID(id int) stakingOption {
	return func(m *StakingMutation) {
		var (
			err   error
			once  sync.Once
			value *Staking
		)
		m.oldValue = func(ctx context.Context) (*Staking, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Staking.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStaking sets the old Staking of the mutation.
func withStaking(node *Staking) stakingOption {
	return func(m *StakingMutation) {
		m.oldValue = func(context.Context) (*Staking, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StakingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StakingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StakingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StakingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Staking.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNftClassID sets the "nft_class_id" field.
func (m *StakingMutation) SetNftClassID(i int) {
	m.nft_class = &i
}

// NftClassID returns the value of the "nft_class_id" field in the mutation.
func (m *StakingMutation) NftClassID() (r int, exists bool) {
	v := m.nft_class
	if v == nil {
		return
	}
	return *v, true
}

// OldNftClassID returns the old "nft_class_id" field's value of the Staking entity.
// If the Staking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakingMutation) OldNftClassID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNftClassID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNftClassID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNftClassID: %w", err)
	}
	return oldValue.NftClassID, nil
}

// ResetNftClassID resets all changes to the "nft_class_id" field.
func (m *StakingMutation) ResetNftClassID() {
	m.nft_class = nil
}

// SetAccountID sets the "account_id" field.
func (m *StakingMutation) SetAccountID(i int) {
	m.account = &i
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *StakingMutation) AccountID() (r int, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Staking entity.
// If the Staking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakingMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *StakingMutation) ResetAccountID() {
	m.account = nil
}

// SetPoolShare sets the "pool_share" field.
func (m *StakingMutation) SetPoolShare(s string) {
	m.pool_share = &s
}

// PoolShare returns the value of the "pool_share" field in the mutation.
func (m *StakingMutation) PoolShare() (r string, exists bool) {
	v := m.pool_share
	if v == nil {
		return
	}
	return *v, true
}

// OldPoolShare returns the old "pool_share" field's value of the Staking entity.
// If the Staking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakingMutation) OldPoolShare(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoolShare is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoolShare requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoolShare: %w", err)
	}
	return oldValue.PoolShare, nil
}

// ResetPoolShare resets all changes to the "pool_share" field.
func (m *StakingMutation) ResetPoolShare() {
	m.pool_share = nil
}

// SetStakedAmount sets the "staked_amount" field.
func (m *StakingMutation) SetStakedAmount(t typeutil.Uint256) {
	m.staked_amount = &t
}

// StakedAmount returns the value of the "staked_amount" field in the mutation.
func (m *StakingMutation) StakedAmount() (r typeutil.Uint256, exists bool) {
	v := m.staked_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldStakedAmount returns the old "staked_amount" field's value of the Staking entity.
// If the Staking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakingMutation) OldStakedAmount(ctx context.Context) (v typeutil.Uint256, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStakedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStakedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStakedAmount: %w", err)
	}
	return oldValue.StakedAmount, nil
}

// ResetStakedAmount resets all changes to the "staked_amount" field.
func (m *StakingMutation) ResetStakedAmount() {
	m.staked_amount = nil
}

// SetPendingRewardAmount sets the "pending_reward_amount" field.
func (m *StakingMutation) SetPendingRewardAmount(t typeutil.Uint256) {
	m.pending_reward_amount = &t
}

// PendingRewardAmount returns the value of the "pending_reward_amount" field in the mutation.
func (m *StakingMutation) PendingRewardAmount() (r typeutil.Uint256, exists bool) {
	v := m.pending_reward_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldPendingRewardAmount returns the old "pending_reward_amount" field's value of the Staking entity.
// If the Staking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakingMutation) OldPendingRewardAmount(ctx context.Context) (v typeutil.Uint256, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPendingRewardAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPendingRewardAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPendingRewardAmount: %w", err)
	}
	return oldValue.PendingRewardAmount, nil
}

// ResetPendingRewardAmount resets all changes to the "pending_reward_amount" field.
func (m *StakingMutation) ResetPendingRewardAmount() {
	m.pending_reward_amount = nil
}

// SetClaimedRewardAmount sets the "claimed_reward_amount" field.
func (m *StakingMutation) SetClaimedRewardAmount(t typeutil.Uint256) {
	m.claimed_reward_amount = &t
}

// ClaimedRewardAmount returns the value of the "claimed_reward_amount" field in the mutation.
func (m *StakingMutation) ClaimedRewardAmount() (r typeutil.Uint256, exists bool) {
	v := m.claimed_reward_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimedRewardAmount returns the old "claimed_reward_amount" field's value of the Staking entity.
// If the Staking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakingMutation) OldClaimedRewardAmount(ctx context.Context) (v typeutil.Uint256, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimedRewardAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimedRewardAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimedRewardAmount: %w", err)
	}
	return oldValue.ClaimedRewardAmount, nil
}

// ResetClaimedRewardAmount resets all changes to the "claimed_reward_amount" field.
func (m *StakingMutation) ResetClaimedRewardAmount() {
	m.claimed_reward_amount = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *StakingMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[staking.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *StakingMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *StakingMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *StakingMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearNftClass clears the "nft_class" edge to the NFTClass entity.
func (m *StakingMutation) ClearNftClass() {
	m.clearednft_class = true
	m.clearedFields[staking.FieldNftClassID] = struct{}{}
}

// NftClassCleared reports if the "nft_class" edge to the NFTClass entity was cleared.
func (m *StakingMutation) NftClassCleared() bool {
	return m.clearednft_class
}

// NftClassIDs returns the "nft_class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NftClassID instead. It exists only for internal usage by the builders.
func (m *StakingMutation) NftClassIDs() (ids []int) {
	if id := m.nft_class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNftClass resets all changes to the "nft_class" edge.
func (m *StakingMutation) ResetNftClass() {
	m.nft_class = nil
	m.clearednft_class = false
}

// Where appends a list predicates to the StakingMutation builder.
func (m *StakingMutation) Where(ps ...predicate.Staking) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StakingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StakingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Staking, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StakingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StakingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Staking).
func (m *StakingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StakingMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.nft_class != nil {
		fields = append(fields, staking.FieldNftClassID)
	}
	if m.account != nil {
		fields = append(fields, staking.FieldAccountID)
	}
	if m.pool_share != nil {
		fields = append(fields, staking.FieldPoolShare)
	}
	if m.staked_amount != nil {
		fields = append(fields, staking.FieldStakedAmount)
	}
	if m.pending_reward_amount != nil {
		fields = append(fields, staking.FieldPendingRewardAmount)
	}
	if m.claimed_reward_amount != nil {
		fields = append(fields, staking.FieldClaimedRewardAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StakingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case staking.FieldNftClassID:
		return m.NftClassID()
	case staking.FieldAccountID:
		return m.AccountID()
	case staking.FieldPoolShare:
		return m.PoolShare()
	case staking.FieldStakedAmount:
		return m.StakedAmount()
	case staking.FieldPendingRewardAmount:
		return m.PendingRewardAmount()
	case staking.FieldClaimedRewardAmount:
		return m.ClaimedRewardAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StakingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case staking.FieldNftClassID:
		return m.OldNftClassID(ctx)
	case staking.FieldAccountID:
		return m.OldAccountID(ctx)
	case staking.FieldPoolShare:
		return m.OldPoolShare(ctx)
	case staking.FieldStakedAmount:
		return m.OldStakedAmount(ctx)
	case staking.FieldPendingRewardAmount:
		return m.OldPendingRewardAmount(ctx)
	case staking.FieldClaimedRewardAmount:
		return m.OldClaimedRewardAmount(ctx)
	}
	return nil, fmt.Errorf("unknown Staking field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StakingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case staking.FieldNftClassID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNftClassID(v)
		return nil
	case staking.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case staking.FieldPoolShare:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoolShare(v)
		return nil
	case staking.FieldStakedAmount:
		v, ok := value.(typeutil.Uint256)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStakedAmount(v)
		return nil
	case staking.FieldPendingRewardAmount:
		v, ok := value.(typeutil.Uint256)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPendingRewardAmount(v)
		return nil
	case staking.FieldClaimedRewardAmount:
		v, ok := value.(typeutil.Uint256)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimedRewardAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Staking field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StakingMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StakingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StakingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Staking numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StakingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StakingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StakingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Staking nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StakingMutation) ResetField(name string) error {
	switch name {
	case staking.FieldNftClassID:
		m.ResetNftClassID()
		return nil
	case staking.FieldAccountID:
		m.ResetAccountID()
		return nil
	case staking.FieldPoolShare:
		m.ResetPoolShare()
		return nil
	case staking.FieldStakedAmount:
		m.ResetStakedAmount()
		return nil
	case staking.FieldPendingRewardAmount:
		m.ResetPendingRewardAmount()
		return nil
	case staking.FieldClaimedRewardAmount:
		m.ResetClaimedRewardAmount()
		return nil
	}
	return fmt.Errorf("unknown Staking field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StakingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, staking.EdgeAccount)
	}
	if m.nft_class != nil {
		edges = append(edges, staking.EdgeNftClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StakingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case staking.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case staking.EdgeNftClass:
		if id := m.nft_class; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StakingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StakingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StakingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, staking.EdgeAccount)
	}
	if m.clearednft_class {
		edges = append(edges, staking.EdgeNftClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StakingMutation) EdgeCleared(name string) bool {
	switch name {
	case staking.EdgeAccount:
		return m.clearedaccount
	case staking.EdgeNftClass:
		return m.clearednft_class
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StakingMutation) ClearEdge(name string) error {
	switch name {
	case staking.EdgeAccount:
		m.ClearAccount()
		return nil
	case staking.EdgeNftClass:
		m.ClearNftClass()
		return nil
	}
	return fmt.Errorf("unknown Staking unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StakingMutation) ResetEdge(name string) error {
	switch name {
	case staking.EdgeAccount:
		m.ResetAccount()
		return nil
	case staking.EdgeNftClass:
		m.ResetNftClass()
		return nil
	}
	return fmt.Errorf("unknown Staking edge %s", name)
}

// StakingEventMutation represents an operation that mutates the StakingEvent nodes in the graph.
type StakingEventMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	event_type            *stakingevent.EventType
	staked_amount_added   *typeutil.Uint256
	staked_amount_removed *typeutil.Uint256
	reward_amount_added   *typeutil.Uint256
	reward_amount_removed *typeutil.Uint256
	datetime              *time.Time
	clearedFields         map[string]struct{}
	account               *int
	clearedaccount        bool
	nft_class             *int
	clearednft_class      bool
	done                  bool
	oldValue              func(context.Context) (*StakingEvent, error)
	predicates            []predicate.StakingEvent
}

var _ ent.Mutation = (*StakingEventMutation)(nil)

// stakingeventOption allows management of the mutation configuration using functional options.
type stakingeventOption func(*StakingEventMutation)

// newStakingEventMutation creates new mutation for the StakingEvent entity.
func newStakingEventMutation(c config, op Op, opts ...stakingeventOption) *StakingEventMutation {
	m := &StakingEventMutation{
		config:        c,
		op:            op,
		typ:           TypeStakingEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStakingEventID sets the ID field of the mutation.
func withStakingEventID(id int) stakingeventOption {
	return func(m *StakingEventMutation) {
		var (
			err   error
			once  sync.Once
			value *StakingEvent
		)
		m.oldValue = func(ctx context.Context) (*StakingEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StakingEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStakingEvent sets the old StakingEvent of the mutation.
func withStakingEvent(node *StakingEvent) stakingeventOption {
	return func(m *StakingEventMutation) {
		m.oldValue = func(context.Context) (*StakingEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StakingEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StakingEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StakingEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StakingEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StakingEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEventType sets the "event_type" field.
func (m *StakingEventMutation) SetEventType(st stakingevent.EventType) {
	m.event_type = &st
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *StakingEventMutation) EventType() (r stakingevent.EventType, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the StakingEvent entity.
// If the StakingEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakingEventMutation) OldEventType(ctx context.Context) (v stakingevent.EventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *StakingEventMutation) ResetEventType() {
	m.event_type = nil
}

// SetNftClassID sets the "nft_class_id" field.
func (m *StakingEventMutation) SetNftClassID(i int) {
	m.nft_class = &i
}

// NftClassID returns the value of the "nft_class_id" field in the mutation.
func (m *StakingEventMutation) NftClassID() (r int, exists bool) {
	v := m.nft_class
	if v == nil {
		return
	}
	return *v, true
}

// OldNftClassID returns the old "nft_class_id" field's value of the StakingEvent entity.
// If the StakingEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakingEventMutation) OldNftClassID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNftClassID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNftClassID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNftClassID: %w", err)
	}
	return oldValue.NftClassID, nil
}

// ResetNftClassID resets all changes to the "nft_class_id" field.
func (m *StakingEventMutation) ResetNftClassID() {
	m.nft_class = nil
}

// SetAccountID sets the "account_id" field.
func (m *StakingEventMutation) SetAccountID(i int) {
	m.account = &i
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *StakingEventMutation) AccountID() (r int, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the StakingEvent entity.
// If the StakingEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakingEventMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *StakingEventMutation) ResetAccountID() {
	m.account = nil
}

// SetStakedAmountAdded sets the "staked_amount_added" field.
func (m *StakingEventMutation) SetStakedAmountAdded(t typeutil.Uint256) {
	m.staked_amount_added = &t
}

// StakedAmountAdded returns the value of the "staked_amount_added" field in the mutation.
func (m *StakingEventMutation) StakedAmountAdded() (r typeutil.Uint256, exists bool) {
	v := m.staked_amount_added
	if v == nil {
		return
	}
	return *v, true
}

// OldStakedAmountAdded returns the old "staked_amount_added" field's value of the StakingEvent entity.
// If the StakingEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakingEventMutation) OldStakedAmountAdded(ctx context.Context) (v typeutil.Uint256, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStakedAmountAdded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStakedAmountAdded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStakedAmountAdded: %w", err)
	}
	return oldValue.StakedAmountAdded, nil
}

// ResetStakedAmountAdded resets all changes to the "staked_amount_added" field.
func (m *StakingEventMutation) ResetStakedAmountAdded() {
	m.staked_amount_added = nil
}

// SetStakedAmountRemoved sets the "staked_amount_removed" field.
func (m *StakingEventMutation) SetStakedAmountRemoved(t typeutil.Uint256) {
	m.staked_amount_removed = &t
}

// StakedAmountRemoved returns the value of the "staked_amount_removed" field in the mutation.
func (m *StakingEventMutation) StakedAmountRemoved() (r typeutil.Uint256, exists bool) {
	v := m.staked_amount_removed
	if v == nil {
		return
	}
	return *v, true
}

// OldStakedAmountRemoved returns the old "staked_amount_removed" field's value of the StakingEvent entity.
// If the StakingEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakingEventMutation) OldStakedAmountRemoved(ctx context.Context) (v typeutil.Uint256, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStakedAmountRemoved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStakedAmountRemoved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStakedAmountRemoved: %w", err)
	}
	return oldValue.StakedAmountRemoved, nil
}

// ResetStakedAmountRemoved resets all changes to the "staked_amount_removed" field.
func (m *StakingEventMutation) ResetStakedAmountRemoved() {
	m.staked_amount_removed = nil
}

// SetRewardAmountAdded sets the "reward_amount_added" field.
func (m *StakingEventMutation) SetRewardAmountAdded(t typeutil.Uint256) {
	m.reward_amount_added = &t
}

// RewardAmountAdded returns the value of the "reward_amount_added" field in the mutation.
func (m *StakingEventMutation) RewardAmountAdded() (r typeutil.Uint256, exists bool) {
	v := m.reward_amount_added
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardAmountAdded returns the old "reward_amount_added" field's value of the StakingEvent entity.
// If the StakingEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakingEventMutation) OldRewardAmountAdded(ctx context.Context) (v typeutil.Uint256, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardAmountAdded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardAmountAdded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardAmountAdded: %w", err)
	}
	return oldValue.RewardAmountAdded, nil
}

// ResetRewardAmountAdded resets all changes to the "reward_amount_added" field.
func (m *StakingEventMutation) ResetRewardAmountAdded() {
	m.reward_amount_added = nil
}

// SetRewardAmountRemoved sets the "reward_amount_removed" field.
func (m *StakingEventMutation) SetRewardAmountRemoved(t typeutil.Uint256) {
	m.reward_amount_removed = &t
}

// RewardAmountRemoved returns the value of the "reward_amount_removed" field in the mutation.
func (m *StakingEventMutation) RewardAmountRemoved() (r typeutil.Uint256, exists bool) {
	v := m.reward_amount_removed
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardAmountRemoved returns the old "reward_amount_removed" field's value of the StakingEvent entity.
// If the StakingEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakingEventMutation) OldRewardAmountRemoved(ctx context.Context) (v typeutil.Uint256, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardAmountRemoved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardAmountRemoved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardAmountRemoved: %w", err)
	}
	return oldValue.RewardAmountRemoved, nil
}

// ResetRewardAmountRemoved resets all changes to the "reward_amount_removed" field.
func (m *StakingEventMutation) ResetRewardAmountRemoved() {
	m.reward_amount_removed = nil
}

// SetDatetime sets the "datetime" field.
func (m *StakingEventMutation) SetDatetime(t time.Time) {
	m.datetime = &t
}

// Datetime returns the value of the "datetime" field in the mutation.
func (m *StakingEventMutation) Datetime() (r time.Time, exists bool) {
	v := m.datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldDatetime returns the old "datetime" field's value of the StakingEvent entity.
// If the StakingEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StakingEventMutation) OldDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatetime: %w", err)
	}
	return oldValue.Datetime, nil
}

// ResetDatetime resets all changes to the "datetime" field.
func (m *StakingEventMutation) ResetDatetime() {
	m.datetime = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *StakingEventMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[stakingevent.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *StakingEventMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *StakingEventMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *StakingEventMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearNftClass clears the "nft_class" edge to the NFTClass entity.
func (m *StakingEventMutation) ClearNftClass() {
	m.clearednft_class = true
	m.clearedFields[stakingevent.FieldNftClassID] = struct{}{}
}

// NftClassCleared reports if the "nft_class" edge to the NFTClass entity was cleared.
func (m *StakingEventMutation) NftClassCleared() bool {
	return m.clearednft_class
}

// NftClassIDs returns the "nft_class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NftClassID instead. It exists only for internal usage by the builders.
func (m *StakingEventMutation) NftClassIDs() (ids []int) {
	if id := m.nft_class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNftClass resets all changes to the "nft_class" edge.
func (m *StakingEventMutation) ResetNftClass() {
	m.nft_class = nil
	m.clearednft_class = false
}

// Where appends a list predicates to the StakingEventMutation builder.
func (m *StakingEventMutation) Where(ps ...predicate.StakingEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StakingEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StakingEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StakingEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StakingEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StakingEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StakingEvent).
func (m *StakingEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StakingEventMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.event_type != nil {
		fields = append(fields, stakingevent.FieldEventType)
	}
	if m.nft_class != nil {
		fields = append(fields, stakingevent.FieldNftClassID)
	}
	if m.account != nil {
		fields = append(fields, stakingevent.FieldAccountID)
	}
	if m.staked_amount_added != nil {
		fields = append(fields, stakingevent.FieldStakedAmountAdded)
	}
	if m.staked_amount_removed != nil {
		fields = append(fields, stakingevent.FieldStakedAmountRemoved)
	}
	if m.reward_amount_added != nil {
		fields = append(fields, stakingevent.FieldRewardAmountAdded)
	}
	if m.reward_amount_removed != nil {
		fields = append(fields, stakingevent.FieldRewardAmountRemoved)
	}
	if m.datetime != nil {
		fields = append(fields, stakingevent.FieldDatetime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StakingEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stakingevent.FieldEventType:
		return m.EventType()
	case stakingevent.FieldNftClassID:
		return m.NftClassID()
	case stakingevent.FieldAccountID:
		return m.AccountID()
	case stakingevent.FieldStakedAmountAdded:
		return m.StakedAmountAdded()
	case stakingevent.FieldStakedAmountRemoved:
		return m.StakedAmountRemoved()
	case stakingevent.FieldRewardAmountAdded:
		return m.RewardAmountAdded()
	case stakingevent.FieldRewardAmountRemoved:
		return m.RewardAmountRemoved()
	case stakingevent.FieldDatetime:
		return m.Datetime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StakingEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stakingevent.FieldEventType:
		return m.OldEventType(ctx)
	case stakingevent.FieldNftClassID:
		return m.OldNftClassID(ctx)
	case stakingevent.FieldAccountID:
		return m.OldAccountID(ctx)
	case stakingevent.FieldStakedAmountAdded:
		return m.OldStakedAmountAdded(ctx)
	case stakingevent.FieldStakedAmountRemoved:
		return m.OldStakedAmountRemoved(ctx)
	case stakingevent.FieldRewardAmountAdded:
		return m.OldRewardAmountAdded(ctx)
	case stakingevent.FieldRewardAmountRemoved:
		return m.OldRewardAmountRemoved(ctx)
	case stakingevent.FieldDatetime:
		return m.OldDatetime(ctx)
	}
	return nil, fmt.Errorf("unknown StakingEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StakingEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stakingevent.FieldEventType:
		v, ok := value.(stakingevent.EventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case stakingevent.FieldNftClassID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNftClassID(v)
		return nil
	case stakingevent.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case stakingevent.FieldStakedAmountAdded:
		v, ok := value.(typeutil.Uint256)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStakedAmountAdded(v)
		return nil
	case stakingevent.FieldStakedAmountRemoved:
		v, ok := value.(typeutil.Uint256)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStakedAmountRemoved(v)
		return nil
	case stakingevent.FieldRewardAmountAdded:
		v, ok := value.(typeutil.Uint256)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardAmountAdded(v)
		return nil
	case stakingevent.FieldRewardAmountRemoved:
		v, ok := value.(typeutil.Uint256)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardAmountRemoved(v)
		return nil
	case stakingevent.FieldDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatetime(v)
		return nil
	}
	return fmt.Errorf("unknown StakingEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StakingEventMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StakingEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StakingEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StakingEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StakingEventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StakingEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StakingEventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StakingEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StakingEventMutation) ResetField(name string) error {
	switch name {
	case stakingevent.FieldEventType:
		m.ResetEventType()
		return nil
	case stakingevent.FieldNftClassID:
		m.ResetNftClassID()
		return nil
	case stakingevent.FieldAccountID:
		m.ResetAccountID()
		return nil
	case stakingevent.FieldStakedAmountAdded:
		m.ResetStakedAmountAdded()
		return nil
	case stakingevent.FieldStakedAmountRemoved:
		m.ResetStakedAmountRemoved()
		return nil
	case stakingevent.FieldRewardAmountAdded:
		m.ResetRewardAmountAdded()
		return nil
	case stakingevent.FieldRewardAmountRemoved:
		m.ResetRewardAmountRemoved()
		return nil
	case stakingevent.FieldDatetime:
		m.ResetDatetime()
		return nil
	}
	return fmt.Errorf("unknown StakingEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StakingEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, stakingevent.EdgeAccount)
	}
	if m.nft_class != nil {
		edges = append(edges, stakingevent.EdgeNftClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StakingEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stakingevent.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case stakingevent.EdgeNftClass:
		if id := m.nft_class; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StakingEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StakingEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StakingEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, stakingevent.EdgeAccount)
	}
	if m.clearednft_class {
		edges = append(edges, stakingevent.EdgeNftClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StakingEventMutation) EdgeCleared(name string) bool {
	switch name {
	case stakingevent.EdgeAccount:
		return m.clearedaccount
	case stakingevent.EdgeNftClass:
		return m.clearednft_class
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StakingEventMutation) ClearEdge(name string) error {
	switch name {
	case stakingevent.EdgeAccount:
		m.ClearAccount()
		return nil
	case stakingevent.EdgeNftClass:
		m.ClearNftClass()
		return nil
	}
	return fmt.Errorf("unknown StakingEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StakingEventMutation) ResetEdge(name string) error {
	switch name {
	case stakingevent.EdgeAccount:
		m.ResetAccount()
		return nil
	case stakingevent.EdgeNftClass:
		m.ResetNftClass()
		return nil
	}
	return fmt.Errorf("unknown StakingEvent edge %s", name)
}
