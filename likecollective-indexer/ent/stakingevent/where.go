// Code generated by ent, DO NOT EDIT.

package stakingevent

import (
	"likecollective-indexer/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldEQ(FieldID, id))
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldEQ(FieldID, id))
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldNEQ(FieldID, id))
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldIn(FieldID, ids...))
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldNotIn(FieldID, ids...))
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldGT(FieldID, id))
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldGTE(FieldID, id))
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldLT(FieldID, id))
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldLTE(FieldID, id))
}

// NftClassID applies equality check predicate on the "nft_class_id" field. It's identical to NftClassIDEQ.
func NftClassID(v int) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldEQ(FieldNftClassID, v))
}

// AccountID applies equality check predicate on the "account_id" field. It's identical to AccountIDEQ.
func AccountID(v int) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldEQ(FieldAccountID, v))
}

// Datetime applies equality check predicate on the "datetime" field. It's identical to DatetimeEQ.
func Datetime(v time.Time) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldEQ(FieldDatetime, v))
}

// EventTypeEQ applies the EQ predicate on the "event_type" field.
func EventTypeEQ(v EventType) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldEQ(FieldEventType, v))
}

// EventTypeNEQ applies the NEQ predicate on the "event_type" field.
func EventTypeNEQ(v EventType) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldNEQ(FieldEventType, v))
}

// EventTypeIn applies the In predicate on the "event_type" field.
func EventTypeIn(vs ...EventType) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldIn(FieldEventType, vs...))
}

// EventTypeNotIn applies the NotIn predicate on the "event_type" field.
func EventTypeNotIn(vs ...EventType) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldNotIn(FieldEventType, vs...))
}

// NftClassIDEQ applies the EQ predicate on the "nft_class_id" field.
func NftClassIDEQ(v int) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldEQ(FieldNftClassID, v))
}

// NftClassIDNEQ applies the NEQ predicate on the "nft_class_id" field.
func NftClassIDNEQ(v int) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldNEQ(FieldNftClassID, v))
}

// NftClassIDIn applies the In predicate on the "nft_class_id" field.
func NftClassIDIn(vs ...int) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldIn(FieldNftClassID, vs...))
}

// NftClassIDNotIn applies the NotIn predicate on the "nft_class_id" field.
func NftClassIDNotIn(vs ...int) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldNotIn(FieldNftClassID, vs...))
}

// AccountIDEQ applies the EQ predicate on the "account_id" field.
func AccountIDEQ(v int) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldEQ(FieldAccountID, v))
}

// AccountIDNEQ applies the NEQ predicate on the "account_id" field.
func AccountIDNEQ(v int) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldNEQ(FieldAccountID, v))
}

// AccountIDIn applies the In predicate on the "account_id" field.
func AccountIDIn(vs ...int) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldIn(FieldAccountID, vs...))
}

// AccountIDNotIn applies the NotIn predicate on the "account_id" field.
func AccountIDNotIn(vs ...int) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldNotIn(FieldAccountID, vs...))
}

// DatetimeEQ applies the EQ predicate on the "datetime" field.
func DatetimeEQ(v time.Time) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldEQ(FieldDatetime, v))
}

// DatetimeNEQ applies the NEQ predicate on the "datetime" field.
func DatetimeNEQ(v time.Time) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldNEQ(FieldDatetime, v))
}

// DatetimeIn applies the In predicate on the "datetime" field.
func DatetimeIn(vs ...time.Time) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldIn(FieldDatetime, vs...))
}

// DatetimeNotIn applies the NotIn predicate on the "datetime" field.
func DatetimeNotIn(vs ...time.Time) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldNotIn(FieldDatetime, vs...))
}

// DatetimeGT applies the GT predicate on the "datetime" field.
func DatetimeGT(v time.Time) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldGT(FieldDatetime, v))
}

// DatetimeGTE applies the GTE predicate on the "datetime" field.
func DatetimeGTE(v time.Time) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldGTE(FieldDatetime, v))
}

// DatetimeLT applies the LT predicate on the "datetime" field.
func DatetimeLT(v time.Time) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldLT(FieldDatetime, v))
}

// DatetimeLTE applies the LTE predicate on the "datetime" field.
func DatetimeLTE(v time.Time) predicate.StakingEvent {
	return predicate.StakingEvent(sql.FieldLTE(FieldDatetime, v))
}

// HasAccount applies the HasEdge predicate on the "account" edge.
func HasAccount() predicate.StakingEvent {
	return predicate.StakingEvent(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, AccountTable, AccountColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAccountWith applies the HasEdge predicate on the "account" edge with a given conditions (other predicates).
func HasAccountWith(preds ...predicate.Account) predicate.StakingEvent {
	return predicate.StakingEvent(func(s *sql.Selector) {
		step := newAccountStep()
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasNftClass applies the HasEdge predicate on the "nft_class" edge.
func HasNftClass() predicate.StakingEvent {
	return predicate.StakingEvent(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, NftClassTable, NftClassColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasNftClassWith applies the HasEdge predicate on the "nft_class" edge with a given conditions (other predicates).
func HasNftClassWith(preds ...predicate.NFTClass) predicate.StakingEvent {
	return predicate.StakingEvent(func(s *sql.Selector) {
		step := newNftClassStep()
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.StakingEvent) predicate.StakingEvent {
	return predicate.StakingEvent(sql.AndPredicates(predicates...))
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.StakingEvent) predicate.StakingEvent {
	return predicate.StakingEvent(sql.OrPredicates(predicates...))
}

// Not applies the not operator on the given predicate.
func Not(p predicate.StakingEvent) predicate.StakingEvent {
	return predicate.StakingEvent(sql.NotPredicates(p))
}
