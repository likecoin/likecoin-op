// Code generated by ent, DO NOT EDIT.

package account

import (
	"likecollective-indexer/ent/schema/typeutil"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

const (
	// Label holds the string label denoting the account type in the database.
	Label = "account"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldEvmAddress holds the string denoting the evm_address field in the database.
	FieldEvmAddress = "evm_address"
	// FieldStakedAmount holds the string denoting the staked_amount field in the database.
	FieldStakedAmount = "staked_amount"
	// FieldPendingRewardAmount holds the string denoting the pending_reward_amount field in the database.
	FieldPendingRewardAmount = "pending_reward_amount"
	// FieldClaimedRewardAmount holds the string denoting the claimed_reward_amount field in the database.
	FieldClaimedRewardAmount = "claimed_reward_amount"
	// EdgeNftClasses holds the string denoting the nft_classes edge name in mutations.
	EdgeNftClasses = "nft_classes"
	// EdgeStakingEvents holds the string denoting the staking_events edge name in mutations.
	EdgeStakingEvents = "staking_events"
	// EdgeStakings holds the string denoting the stakings edge name in mutations.
	EdgeStakings = "stakings"
	// Table holds the table name of the account in the database.
	Table = "accounts"
	// NftClassesTable is the table that holds the nft_classes relation/edge. The primary key declared below.
	NftClassesTable = "stakings"
	// NftClassesInverseTable is the table name for the NFTClass entity.
	// It exists in this package in order to avoid circular dependency with the "nftclass" package.
	NftClassesInverseTable = "nft_classes"
	// StakingEventsTable is the table that holds the staking_events relation/edge.
	StakingEventsTable = "staking_events"
	// StakingEventsInverseTable is the table name for the StakingEvent entity.
	// It exists in this package in order to avoid circular dependency with the "stakingevent" package.
	StakingEventsInverseTable = "staking_events"
	// StakingEventsColumn is the table column denoting the staking_events relation/edge.
	StakingEventsColumn = "account_id"
	// StakingsTable is the table that holds the stakings relation/edge.
	StakingsTable = "stakings"
	// StakingsInverseTable is the table name for the Staking entity.
	// It exists in this package in order to avoid circular dependency with the "staking" package.
	StakingsInverseTable = "stakings"
	// StakingsColumn is the table column denoting the stakings relation/edge.
	StakingsColumn = "account_id"
)

// Columns holds all SQL columns for account fields.
var Columns = []string{
	FieldID,
	FieldEvmAddress,
	FieldStakedAmount,
	FieldPendingRewardAmount,
	FieldClaimedRewardAmount,
}

var (
	// NftClassesPrimaryKey and NftClassesColumn2 are the table columns denoting the
	// primary key for the nft_classes relation (M2M).
	NftClassesPrimaryKey = []string{"account_id", "nft_class_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

var (
	// EvmAddressValidator is a validator for the "evm_address" field. It is called by the builders before save.
	EvmAddressValidator func(string) error
	// ValueScanner of all Account fields.
	ValueScanner struct {
		StakedAmount        field.TypeValueScanner[typeutil.Uint256]
		PendingRewardAmount field.TypeValueScanner[typeutil.Uint256]
		ClaimedRewardAmount field.TypeValueScanner[typeutil.Uint256]
	}
)

// OrderOption defines the ordering options for the Account queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByEvmAddress orders the results by the evm_address field.
func ByEvmAddress(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldEvmAddress, opts...).ToFunc()
}

// ByStakedAmount orders the results by the staked_amount field.
func ByStakedAmount(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStakedAmount, opts...).ToFunc()
}

// ByPendingRewardAmount orders the results by the pending_reward_amount field.
func ByPendingRewardAmount(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPendingRewardAmount, opts...).ToFunc()
}

// ByClaimedRewardAmount orders the results by the claimed_reward_amount field.
func ByClaimedRewardAmount(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldClaimedRewardAmount, opts...).ToFunc()
}

// ByNftClassesCount orders the results by nft_classes count.
func ByNftClassesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newNftClassesStep(), opts...)
	}
}

// ByNftClasses orders the results by nft_classes terms.
func ByNftClasses(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newNftClassesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByStakingEventsCount orders the results by staking_events count.
func ByStakingEventsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newStakingEventsStep(), opts...)
	}
}

// ByStakingEvents orders the results by staking_events terms.
func ByStakingEvents(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newStakingEventsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByStakingsCount orders the results by stakings count.
func ByStakingsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newStakingsStep(), opts...)
	}
}

// ByStakings orders the results by stakings terms.
func ByStakings(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newStakingsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newNftClassesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(NftClassesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, false, NftClassesTable, NftClassesPrimaryKey...),
	)
}
func newStakingEventsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(StakingEventsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, true, StakingEventsTable, StakingEventsColumn),
	)
}
func newStakingsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(StakingsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, true, StakingsTable, StakingsColumn),
	)
}
