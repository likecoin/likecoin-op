// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"likenft-indexer/ent/account"
	"likenft-indexer/ent/evmevent"
	"likenft-indexer/ent/evmeventprocessedblockheight"
	"likenft-indexer/ent/nft"
	"likenft-indexer/ent/nftclass"
	"likenft-indexer/ent/predicate"
	"likenft-indexer/ent/schema/typeutil"
	"likenft-indexer/ent/transactionmemo"
	"likenft-indexer/internal/evm/model"
	"math/big"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount                      = "Account"
	TypeEVMEvent                     = "EVMEvent"
	TypeEVMEventProcessedBlockHeight = "EVMEventProcessedBlockHeight"
	TypeNFT                          = "NFT"
	TypeNFTClass                     = "NFTClass"
	TypeTransactionMemo              = "TransactionMemo"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	cosmos_address     *string
	evm_address        *string
	likeid             *string
	clearedFields      map[string]struct{}
	nft_classes        map[int]struct{}
	removednft_classes map[int]struct{}
	clearednft_classes bool
	nfts               map[int]struct{}
	removednfts        map[int]struct{}
	clearednfts        bool
	done               bool
	oldValue           func(context.Context) (*Account, error)
	predicates         []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCosmosAddress sets the "cosmos_address" field.
func (m *AccountMutation) SetCosmosAddress(s string) {
	m.cosmos_address = &s
}

// CosmosAddress returns the value of the "cosmos_address" field in the mutation.
func (m *AccountMutation) CosmosAddress() (r string, exists bool) {
	v := m.cosmos_address
	if v == nil {
		return
	}
	return *v, true
}

// OldCosmosAddress returns the old "cosmos_address" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCosmosAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCosmosAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCosmosAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCosmosAddress: %w", err)
	}
	return oldValue.CosmosAddress, nil
}

// ClearCosmosAddress clears the value of the "cosmos_address" field.
func (m *AccountMutation) ClearCosmosAddress() {
	m.cosmos_address = nil
	m.clearedFields[account.FieldCosmosAddress] = struct{}{}
}

// CosmosAddressCleared returns if the "cosmos_address" field was cleared in this mutation.
func (m *AccountMutation) CosmosAddressCleared() bool {
	_, ok := m.clearedFields[account.FieldCosmosAddress]
	return ok
}

// ResetCosmosAddress resets all changes to the "cosmos_address" field.
func (m *AccountMutation) ResetCosmosAddress() {
	m.cosmos_address = nil
	delete(m.clearedFields, account.FieldCosmosAddress)
}

// SetEvmAddress sets the "evm_address" field.
func (m *AccountMutation) SetEvmAddress(s string) {
	m.evm_address = &s
}

// EvmAddress returns the value of the "evm_address" field in the mutation.
func (m *AccountMutation) EvmAddress() (r string, exists bool) {
	v := m.evm_address
	if v == nil {
		return
	}
	return *v, true
}

// OldEvmAddress returns the old "evm_address" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldEvmAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvmAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvmAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvmAddress: %w", err)
	}
	return oldValue.EvmAddress, nil
}

// ResetEvmAddress resets all changes to the "evm_address" field.
func (m *AccountMutation) ResetEvmAddress() {
	m.evm_address = nil
}

// SetLikeid sets the "likeid" field.
func (m *AccountMutation) SetLikeid(s string) {
	m.likeid = &s
}

// Likeid returns the value of the "likeid" field in the mutation.
func (m *AccountMutation) Likeid() (r string, exists bool) {
	v := m.likeid
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeid returns the old "likeid" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldLikeid(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeid: %w", err)
	}
	return oldValue.Likeid, nil
}

// ClearLikeid clears the value of the "likeid" field.
func (m *AccountMutation) ClearLikeid() {
	m.likeid = nil
	m.clearedFields[account.FieldLikeid] = struct{}{}
}

// LikeidCleared returns if the "likeid" field was cleared in this mutation.
func (m *AccountMutation) LikeidCleared() bool {
	_, ok := m.clearedFields[account.FieldLikeid]
	return ok
}

// ResetLikeid resets all changes to the "likeid" field.
func (m *AccountMutation) ResetLikeid() {
	m.likeid = nil
	delete(m.clearedFields, account.FieldLikeid)
}

// AddNftClassIDs adds the "nft_classes" edge to the NFTClass entity by ids.
func (m *AccountMutation) AddNftClassIDs(ids ...int) {
	if m.nft_classes == nil {
		m.nft_classes = make(map[int]struct{})
	}
	for i := range ids {
		m.nft_classes[ids[i]] = struct{}{}
	}
}

// ClearNftClasses clears the "nft_classes" edge to the NFTClass entity.
func (m *AccountMutation) ClearNftClasses() {
	m.clearednft_classes = true
}

// NftClassesCleared reports if the "nft_classes" edge to the NFTClass entity was cleared.
func (m *AccountMutation) NftClassesCleared() bool {
	return m.clearednft_classes
}

// RemoveNftClassIDs removes the "nft_classes" edge to the NFTClass entity by IDs.
func (m *AccountMutation) RemoveNftClassIDs(ids ...int) {
	if m.removednft_classes == nil {
		m.removednft_classes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.nft_classes, ids[i])
		m.removednft_classes[ids[i]] = struct{}{}
	}
}

// RemovedNftClasses returns the removed IDs of the "nft_classes" edge to the NFTClass entity.
func (m *AccountMutation) RemovedNftClassesIDs() (ids []int) {
	for id := range m.removednft_classes {
		ids = append(ids, id)
	}
	return
}

// NftClassesIDs returns the "nft_classes" edge IDs in the mutation.
func (m *AccountMutation) NftClassesIDs() (ids []int) {
	for id := range m.nft_classes {
		ids = append(ids, id)
	}
	return
}

// ResetNftClasses resets all changes to the "nft_classes" edge.
func (m *AccountMutation) ResetNftClasses() {
	m.nft_classes = nil
	m.clearednft_classes = false
	m.removednft_classes = nil
}

// AddNftIDs adds the "nfts" edge to the NFT entity by ids.
func (m *AccountMutation) AddNftIDs(ids ...int) {
	if m.nfts == nil {
		m.nfts = make(map[int]struct{})
	}
	for i := range ids {
		m.nfts[ids[i]] = struct{}{}
	}
}

// ClearNfts clears the "nfts" edge to the NFT entity.
func (m *AccountMutation) ClearNfts() {
	m.clearednfts = true
}

// NftsCleared reports if the "nfts" edge to the NFT entity was cleared.
func (m *AccountMutation) NftsCleared() bool {
	return m.clearednfts
}

// RemoveNftIDs removes the "nfts" edge to the NFT entity by IDs.
func (m *AccountMutation) RemoveNftIDs(ids ...int) {
	if m.removednfts == nil {
		m.removednfts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.nfts, ids[i])
		m.removednfts[ids[i]] = struct{}{}
	}
}

// RemovedNfts returns the removed IDs of the "nfts" edge to the NFT entity.
func (m *AccountMutation) RemovedNftsIDs() (ids []int) {
	for id := range m.removednfts {
		ids = append(ids, id)
	}
	return
}

// NftsIDs returns the "nfts" edge IDs in the mutation.
func (m *AccountMutation) NftsIDs() (ids []int) {
	for id := range m.nfts {
		ids = append(ids, id)
	}
	return
}

// ResetNfts resets all changes to the "nfts" edge.
func (m *AccountMutation) ResetNfts() {
	m.nfts = nil
	m.clearednfts = false
	m.removednfts = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.cosmos_address != nil {
		fields = append(fields, account.FieldCosmosAddress)
	}
	if m.evm_address != nil {
		fields = append(fields, account.FieldEvmAddress)
	}
	if m.likeid != nil {
		fields = append(fields, account.FieldLikeid)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCosmosAddress:
		return m.CosmosAddress()
	case account.FieldEvmAddress:
		return m.EvmAddress()
	case account.FieldLikeid:
		return m.Likeid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCosmosAddress:
		return m.OldCosmosAddress(ctx)
	case account.FieldEvmAddress:
		return m.OldEvmAddress(ctx)
	case account.FieldLikeid:
		return m.OldLikeid(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCosmosAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCosmosAddress(v)
		return nil
	case account.FieldEvmAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvmAddress(v)
		return nil
	case account.FieldLikeid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeid(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldCosmosAddress) {
		fields = append(fields, account.FieldCosmosAddress)
	}
	if m.FieldCleared(account.FieldLikeid) {
		fields = append(fields, account.FieldLikeid)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldCosmosAddress:
		m.ClearCosmosAddress()
		return nil
	case account.FieldLikeid:
		m.ClearLikeid()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCosmosAddress:
		m.ResetCosmosAddress()
		return nil
	case account.FieldEvmAddress:
		m.ResetEvmAddress()
		return nil
	case account.FieldLikeid:
		m.ResetLikeid()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.nft_classes != nil {
		edges = append(edges, account.EdgeNftClasses)
	}
	if m.nfts != nil {
		edges = append(edges, account.EdgeNfts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeNftClasses:
		ids := make([]ent.Value, 0, len(m.nft_classes))
		for id := range m.nft_classes {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeNfts:
		ids := make([]ent.Value, 0, len(m.nfts))
		for id := range m.nfts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednft_classes != nil {
		edges = append(edges, account.EdgeNftClasses)
	}
	if m.removednfts != nil {
		edges = append(edges, account.EdgeNfts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeNftClasses:
		ids := make([]ent.Value, 0, len(m.removednft_classes))
		for id := range m.removednft_classes {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeNfts:
		ids := make([]ent.Value, 0, len(m.removednfts))
		for id := range m.removednfts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednft_classes {
		edges = append(edges, account.EdgeNftClasses)
	}
	if m.clearednfts {
		edges = append(edges, account.EdgeNfts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeNftClasses:
		return m.clearednft_classes
	case account.EdgeNfts:
		return m.clearednfts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeNftClasses:
		m.ResetNftClasses()
		return nil
	case account.EdgeNfts:
		m.ResetNfts()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// EVMEventMutation represents an operation that mutates the EVMEvent nodes in the graph.
type EVMEventMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	transaction_hash     *string
	transaction_index    *uint
	addtransaction_index *int
	block_hash           *string
	block_number         *typeutil.Uint64
	addblock_number      *typeutil.Uint64
	log_index            *uint
	addlog_index         *int
	address              *string
	topic0               *string
	topic0_hex           *string
	topic1               *string
	topic1_hex           *string
	topic2               *string
	topic2_hex           *string
	topic3               *string
	topic3_hex           *string
	data                 *string
	data_hex             *string
	removed              *bool
	status               *evmevent.Status
	failed_reason        *string
	timestamp            *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*EVMEvent, error)
	predicates           []predicate.EVMEvent
}

var _ ent.Mutation = (*EVMEventMutation)(nil)

// evmeventOption allows management of the mutation configuration using functional options.
type evmeventOption func(*EVMEventMutation)

// newEVMEventMutation creates new mutation for the EVMEvent entity.
func newEVMEventMutation(c config, op Op, opts ...evmeventOption) *EVMEventMutation {
	m := &EVMEventMutation{
		config:        c,
		op:            op,
		typ:           TypeEVMEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEVMEventID sets the ID field of the mutation.
func withEVMEventID(id int) evmeventOption {
	return func(m *EVMEventMutation) {
		var (
			err   error
			once  sync.Once
			value *EVMEvent
		)
		m.oldValue = func(ctx context.Context) (*EVMEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EVMEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEVMEvent sets the old EVMEvent of the mutation.
func withEVMEvent(node *EVMEvent) evmeventOption {
	return func(m *EVMEventMutation) {
		m.oldValue = func(context.Context) (*EVMEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EVMEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EVMEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EVMEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EVMEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EVMEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTransactionHash sets the "transaction_hash" field.
func (m *EVMEventMutation) SetTransactionHash(s string) {
	m.transaction_hash = &s
}

// TransactionHash returns the value of the "transaction_hash" field in the mutation.
func (m *EVMEventMutation) TransactionHash() (r string, exists bool) {
	v := m.transaction_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionHash returns the old "transaction_hash" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTransactionHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionHash: %w", err)
	}
	return oldValue.TransactionHash, nil
}

// ResetTransactionHash resets all changes to the "transaction_hash" field.
func (m *EVMEventMutation) ResetTransactionHash() {
	m.transaction_hash = nil
}

// SetTransactionIndex sets the "transaction_index" field.
func (m *EVMEventMutation) SetTransactionIndex(u uint) {
	m.transaction_index = &u
	m.addtransaction_index = nil
}

// TransactionIndex returns the value of the "transaction_index" field in the mutation.
func (m *EVMEventMutation) TransactionIndex() (r uint, exists bool) {
	v := m.transaction_index
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionIndex returns the old "transaction_index" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTransactionIndex(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionIndex: %w", err)
	}
	return oldValue.TransactionIndex, nil
}

// AddTransactionIndex adds u to the "transaction_index" field.
func (m *EVMEventMutation) AddTransactionIndex(u int) {
	if m.addtransaction_index != nil {
		*m.addtransaction_index += u
	} else {
		m.addtransaction_index = &u
	}
}

// AddedTransactionIndex returns the value that was added to the "transaction_index" field in this mutation.
func (m *EVMEventMutation) AddedTransactionIndex() (r int, exists bool) {
	v := m.addtransaction_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetTransactionIndex resets all changes to the "transaction_index" field.
func (m *EVMEventMutation) ResetTransactionIndex() {
	m.transaction_index = nil
	m.addtransaction_index = nil
}

// SetBlockHash sets the "block_hash" field.
func (m *EVMEventMutation) SetBlockHash(s string) {
	m.block_hash = &s
}

// BlockHash returns the value of the "block_hash" field in the mutation.
func (m *EVMEventMutation) BlockHash() (r string, exists bool) {
	v := m.block_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockHash returns the old "block_hash" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldBlockHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockHash: %w", err)
	}
	return oldValue.BlockHash, nil
}

// ResetBlockHash resets all changes to the "block_hash" field.
func (m *EVMEventMutation) ResetBlockHash() {
	m.block_hash = nil
}

// SetBlockNumber sets the "block_number" field.
func (m *EVMEventMutation) SetBlockNumber(t typeutil.Uint64) {
	m.block_number = &t
	m.addblock_number = nil
}

// BlockNumber returns the value of the "block_number" field in the mutation.
func (m *EVMEventMutation) BlockNumber() (r typeutil.Uint64, exists bool) {
	v := m.block_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockNumber returns the old "block_number" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldBlockNumber(ctx context.Context) (v typeutil.Uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockNumber: %w", err)
	}
	return oldValue.BlockNumber, nil
}

// AddBlockNumber adds t to the "block_number" field.
func (m *EVMEventMutation) AddBlockNumber(t typeutil.Uint64) {
	if m.addblock_number != nil {
		*m.addblock_number += t
	} else {
		m.addblock_number = &t
	}
}

// AddedBlockNumber returns the value that was added to the "block_number" field in this mutation.
func (m *EVMEventMutation) AddedBlockNumber() (r typeutil.Uint64, exists bool) {
	v := m.addblock_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockNumber resets all changes to the "block_number" field.
func (m *EVMEventMutation) ResetBlockNumber() {
	m.block_number = nil
	m.addblock_number = nil
}

// SetLogIndex sets the "log_index" field.
func (m *EVMEventMutation) SetLogIndex(u uint) {
	m.log_index = &u
	m.addlog_index = nil
}

// LogIndex returns the value of the "log_index" field in the mutation.
func (m *EVMEventMutation) LogIndex() (r uint, exists bool) {
	v := m.log_index
	if v == nil {
		return
	}
	return *v, true
}

// OldLogIndex returns the old "log_index" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldLogIndex(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogIndex: %w", err)
	}
	return oldValue.LogIndex, nil
}

// AddLogIndex adds u to the "log_index" field.
func (m *EVMEventMutation) AddLogIndex(u int) {
	if m.addlog_index != nil {
		*m.addlog_index += u
	} else {
		m.addlog_index = &u
	}
}

// AddedLogIndex returns the value that was added to the "log_index" field in this mutation.
func (m *EVMEventMutation) AddedLogIndex() (r int, exists bool) {
	v := m.addlog_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetLogIndex resets all changes to the "log_index" field.
func (m *EVMEventMutation) ResetLogIndex() {
	m.log_index = nil
	m.addlog_index = nil
}

// SetAddress sets the "address" field.
func (m *EVMEventMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *EVMEventMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *EVMEventMutation) ResetAddress() {
	m.address = nil
}

// SetTopic0 sets the "topic0" field.
func (m *EVMEventMutation) SetTopic0(s string) {
	m.topic0 = &s
}

// Topic0 returns the value of the "topic0" field in the mutation.
func (m *EVMEventMutation) Topic0() (r string, exists bool) {
	v := m.topic0
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic0 returns the old "topic0" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic0(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic0 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic0 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic0: %w", err)
	}
	return oldValue.Topic0, nil
}

// ResetTopic0 resets all changes to the "topic0" field.
func (m *EVMEventMutation) ResetTopic0() {
	m.topic0 = nil
}

// SetTopic0Hex sets the "topic0_hex" field.
func (m *EVMEventMutation) SetTopic0Hex(s string) {
	m.topic0_hex = &s
}

// Topic0Hex returns the value of the "topic0_hex" field in the mutation.
func (m *EVMEventMutation) Topic0Hex() (r string, exists bool) {
	v := m.topic0_hex
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic0Hex returns the old "topic0_hex" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic0Hex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic0Hex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic0Hex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic0Hex: %w", err)
	}
	return oldValue.Topic0Hex, nil
}

// ResetTopic0Hex resets all changes to the "topic0_hex" field.
func (m *EVMEventMutation) ResetTopic0Hex() {
	m.topic0_hex = nil
}

// SetTopic1 sets the "topic1" field.
func (m *EVMEventMutation) SetTopic1(s string) {
	m.topic1 = &s
}

// Topic1 returns the value of the "topic1" field in the mutation.
func (m *EVMEventMutation) Topic1() (r string, exists bool) {
	v := m.topic1
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic1 returns the old "topic1" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic1(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic1: %w", err)
	}
	return oldValue.Topic1, nil
}

// ClearTopic1 clears the value of the "topic1" field.
func (m *EVMEventMutation) ClearTopic1() {
	m.topic1 = nil
	m.clearedFields[evmevent.FieldTopic1] = struct{}{}
}

// Topic1Cleared returns if the "topic1" field was cleared in this mutation.
func (m *EVMEventMutation) Topic1Cleared() bool {
	_, ok := m.clearedFields[evmevent.FieldTopic1]
	return ok
}

// ResetTopic1 resets all changes to the "topic1" field.
func (m *EVMEventMutation) ResetTopic1() {
	m.topic1 = nil
	delete(m.clearedFields, evmevent.FieldTopic1)
}

// SetTopic1Hex sets the "topic1_hex" field.
func (m *EVMEventMutation) SetTopic1Hex(s string) {
	m.topic1_hex = &s
}

// Topic1Hex returns the value of the "topic1_hex" field in the mutation.
func (m *EVMEventMutation) Topic1Hex() (r string, exists bool) {
	v := m.topic1_hex
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic1Hex returns the old "topic1_hex" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic1Hex(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic1Hex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic1Hex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic1Hex: %w", err)
	}
	return oldValue.Topic1Hex, nil
}

// ClearTopic1Hex clears the value of the "topic1_hex" field.
func (m *EVMEventMutation) ClearTopic1Hex() {
	m.topic1_hex = nil
	m.clearedFields[evmevent.FieldTopic1Hex] = struct{}{}
}

// Topic1HexCleared returns if the "topic1_hex" field was cleared in this mutation.
func (m *EVMEventMutation) Topic1HexCleared() bool {
	_, ok := m.clearedFields[evmevent.FieldTopic1Hex]
	return ok
}

// ResetTopic1Hex resets all changes to the "topic1_hex" field.
func (m *EVMEventMutation) ResetTopic1Hex() {
	m.topic1_hex = nil
	delete(m.clearedFields, evmevent.FieldTopic1Hex)
}

// SetTopic2 sets the "topic2" field.
func (m *EVMEventMutation) SetTopic2(s string) {
	m.topic2 = &s
}

// Topic2 returns the value of the "topic2" field in the mutation.
func (m *EVMEventMutation) Topic2() (r string, exists bool) {
	v := m.topic2
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic2 returns the old "topic2" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic2(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic2: %w", err)
	}
	return oldValue.Topic2, nil
}

// ClearTopic2 clears the value of the "topic2" field.
func (m *EVMEventMutation) ClearTopic2() {
	m.topic2 = nil
	m.clearedFields[evmevent.FieldTopic2] = struct{}{}
}

// Topic2Cleared returns if the "topic2" field was cleared in this mutation.
func (m *EVMEventMutation) Topic2Cleared() bool {
	_, ok := m.clearedFields[evmevent.FieldTopic2]
	return ok
}

// ResetTopic2 resets all changes to the "topic2" field.
func (m *EVMEventMutation) ResetTopic2() {
	m.topic2 = nil
	delete(m.clearedFields, evmevent.FieldTopic2)
}

// SetTopic2Hex sets the "topic2_hex" field.
func (m *EVMEventMutation) SetTopic2Hex(s string) {
	m.topic2_hex = &s
}

// Topic2Hex returns the value of the "topic2_hex" field in the mutation.
func (m *EVMEventMutation) Topic2Hex() (r string, exists bool) {
	v := m.topic2_hex
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic2Hex returns the old "topic2_hex" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic2Hex(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic2Hex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic2Hex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic2Hex: %w", err)
	}
	return oldValue.Topic2Hex, nil
}

// ClearTopic2Hex clears the value of the "topic2_hex" field.
func (m *EVMEventMutation) ClearTopic2Hex() {
	m.topic2_hex = nil
	m.clearedFields[evmevent.FieldTopic2Hex] = struct{}{}
}

// Topic2HexCleared returns if the "topic2_hex" field was cleared in this mutation.
func (m *EVMEventMutation) Topic2HexCleared() bool {
	_, ok := m.clearedFields[evmevent.FieldTopic2Hex]
	return ok
}

// ResetTopic2Hex resets all changes to the "topic2_hex" field.
func (m *EVMEventMutation) ResetTopic2Hex() {
	m.topic2_hex = nil
	delete(m.clearedFields, evmevent.FieldTopic2Hex)
}

// SetTopic3 sets the "topic3" field.
func (m *EVMEventMutation) SetTopic3(s string) {
	m.topic3 = &s
}

// Topic3 returns the value of the "topic3" field in the mutation.
func (m *EVMEventMutation) Topic3() (r string, exists bool) {
	v := m.topic3
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic3 returns the old "topic3" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic3(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic3: %w", err)
	}
	return oldValue.Topic3, nil
}

// ClearTopic3 clears the value of the "topic3" field.
func (m *EVMEventMutation) ClearTopic3() {
	m.topic3 = nil
	m.clearedFields[evmevent.FieldTopic3] = struct{}{}
}

// Topic3Cleared returns if the "topic3" field was cleared in this mutation.
func (m *EVMEventMutation) Topic3Cleared() bool {
	_, ok := m.clearedFields[evmevent.FieldTopic3]
	return ok
}

// ResetTopic3 resets all changes to the "topic3" field.
func (m *EVMEventMutation) ResetTopic3() {
	m.topic3 = nil
	delete(m.clearedFields, evmevent.FieldTopic3)
}

// SetTopic3Hex sets the "topic3_hex" field.
func (m *EVMEventMutation) SetTopic3Hex(s string) {
	m.topic3_hex = &s
}

// Topic3Hex returns the value of the "topic3_hex" field in the mutation.
func (m *EVMEventMutation) Topic3Hex() (r string, exists bool) {
	v := m.topic3_hex
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic3Hex returns the old "topic3_hex" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic3Hex(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic3Hex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic3Hex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic3Hex: %w", err)
	}
	return oldValue.Topic3Hex, nil
}

// ClearTopic3Hex clears the value of the "topic3_hex" field.
func (m *EVMEventMutation) ClearTopic3Hex() {
	m.topic3_hex = nil
	m.clearedFields[evmevent.FieldTopic3Hex] = struct{}{}
}

// Topic3HexCleared returns if the "topic3_hex" field was cleared in this mutation.
func (m *EVMEventMutation) Topic3HexCleared() bool {
	_, ok := m.clearedFields[evmevent.FieldTopic3Hex]
	return ok
}

// ResetTopic3Hex resets all changes to the "topic3_hex" field.
func (m *EVMEventMutation) ResetTopic3Hex() {
	m.topic3_hex = nil
	delete(m.clearedFields, evmevent.FieldTopic3Hex)
}

// SetData sets the "data" field.
func (m *EVMEventMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *EVMEventMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldData(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *EVMEventMutation) ClearData() {
	m.data = nil
	m.clearedFields[evmevent.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *EVMEventMutation) DataCleared() bool {
	_, ok := m.clearedFields[evmevent.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *EVMEventMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, evmevent.FieldData)
}

// SetDataHex sets the "data_hex" field.
func (m *EVMEventMutation) SetDataHex(s string) {
	m.data_hex = &s
}

// DataHex returns the value of the "data_hex" field in the mutation.
func (m *EVMEventMutation) DataHex() (r string, exists bool) {
	v := m.data_hex
	if v == nil {
		return
	}
	return *v, true
}

// OldDataHex returns the old "data_hex" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldDataHex(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataHex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataHex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataHex: %w", err)
	}
	return oldValue.DataHex, nil
}

// ClearDataHex clears the value of the "data_hex" field.
func (m *EVMEventMutation) ClearDataHex() {
	m.data_hex = nil
	m.clearedFields[evmevent.FieldDataHex] = struct{}{}
}

// DataHexCleared returns if the "data_hex" field was cleared in this mutation.
func (m *EVMEventMutation) DataHexCleared() bool {
	_, ok := m.clearedFields[evmevent.FieldDataHex]
	return ok
}

// ResetDataHex resets all changes to the "data_hex" field.
func (m *EVMEventMutation) ResetDataHex() {
	m.data_hex = nil
	delete(m.clearedFields, evmevent.FieldDataHex)
}

// SetRemoved sets the "removed" field.
func (m *EVMEventMutation) SetRemoved(b bool) {
	m.removed = &b
}

// Removed returns the value of the "removed" field in the mutation.
func (m *EVMEventMutation) Removed() (r bool, exists bool) {
	v := m.removed
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoved returns the old "removed" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldRemoved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoved: %w", err)
	}
	return oldValue.Removed, nil
}

// ResetRemoved resets all changes to the "removed" field.
func (m *EVMEventMutation) ResetRemoved() {
	m.removed = nil
}

// SetStatus sets the "status" field.
func (m *EVMEventMutation) SetStatus(e evmevent.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EVMEventMutation) Status() (r evmevent.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldStatus(ctx context.Context) (v evmevent.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EVMEventMutation) ResetStatus() {
	m.status = nil
}

// SetFailedReason sets the "failed_reason" field.
func (m *EVMEventMutation) SetFailedReason(s string) {
	m.failed_reason = &s
}

// FailedReason returns the value of the "failed_reason" field in the mutation.
func (m *EVMEventMutation) FailedReason() (r string, exists bool) {
	v := m.failed_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailedReason returns the old "failed_reason" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldFailedReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailedReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailedReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailedReason: %w", err)
	}
	return oldValue.FailedReason, nil
}

// ClearFailedReason clears the value of the "failed_reason" field.
func (m *EVMEventMutation) ClearFailedReason() {
	m.failed_reason = nil
	m.clearedFields[evmevent.FieldFailedReason] = struct{}{}
}

// FailedReasonCleared returns if the "failed_reason" field was cleared in this mutation.
func (m *EVMEventMutation) FailedReasonCleared() bool {
	_, ok := m.clearedFields[evmevent.FieldFailedReason]
	return ok
}

// ResetFailedReason resets all changes to the "failed_reason" field.
func (m *EVMEventMutation) ResetFailedReason() {
	m.failed_reason = nil
	delete(m.clearedFields, evmevent.FieldFailedReason)
}

// SetTimestamp sets the "timestamp" field.
func (m *EVMEventMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *EVMEventMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *EVMEventMutation) ResetTimestamp() {
	m.timestamp = nil
}

// Where appends a list predicates to the EVMEventMutation builder.
func (m *EVMEventMutation) Where(ps ...predicate.EVMEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EVMEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EVMEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EVMEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EVMEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EVMEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EVMEvent).
func (m *EVMEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EVMEventMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.transaction_hash != nil {
		fields = append(fields, evmevent.FieldTransactionHash)
	}
	if m.transaction_index != nil {
		fields = append(fields, evmevent.FieldTransactionIndex)
	}
	if m.block_hash != nil {
		fields = append(fields, evmevent.FieldBlockHash)
	}
	if m.block_number != nil {
		fields = append(fields, evmevent.FieldBlockNumber)
	}
	if m.log_index != nil {
		fields = append(fields, evmevent.FieldLogIndex)
	}
	if m.address != nil {
		fields = append(fields, evmevent.FieldAddress)
	}
	if m.topic0 != nil {
		fields = append(fields, evmevent.FieldTopic0)
	}
	if m.topic0_hex != nil {
		fields = append(fields, evmevent.FieldTopic0Hex)
	}
	if m.topic1 != nil {
		fields = append(fields, evmevent.FieldTopic1)
	}
	if m.topic1_hex != nil {
		fields = append(fields, evmevent.FieldTopic1Hex)
	}
	if m.topic2 != nil {
		fields = append(fields, evmevent.FieldTopic2)
	}
	if m.topic2_hex != nil {
		fields = append(fields, evmevent.FieldTopic2Hex)
	}
	if m.topic3 != nil {
		fields = append(fields, evmevent.FieldTopic3)
	}
	if m.topic3_hex != nil {
		fields = append(fields, evmevent.FieldTopic3Hex)
	}
	if m.data != nil {
		fields = append(fields, evmevent.FieldData)
	}
	if m.data_hex != nil {
		fields = append(fields, evmevent.FieldDataHex)
	}
	if m.removed != nil {
		fields = append(fields, evmevent.FieldRemoved)
	}
	if m.status != nil {
		fields = append(fields, evmevent.FieldStatus)
	}
	if m.failed_reason != nil {
		fields = append(fields, evmevent.FieldFailedReason)
	}
	if m.timestamp != nil {
		fields = append(fields, evmevent.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EVMEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case evmevent.FieldTransactionHash:
		return m.TransactionHash()
	case evmevent.FieldTransactionIndex:
		return m.TransactionIndex()
	case evmevent.FieldBlockHash:
		return m.BlockHash()
	case evmevent.FieldBlockNumber:
		return m.BlockNumber()
	case evmevent.FieldLogIndex:
		return m.LogIndex()
	case evmevent.FieldAddress:
		return m.Address()
	case evmevent.FieldTopic0:
		return m.Topic0()
	case evmevent.FieldTopic0Hex:
		return m.Topic0Hex()
	case evmevent.FieldTopic1:
		return m.Topic1()
	case evmevent.FieldTopic1Hex:
		return m.Topic1Hex()
	case evmevent.FieldTopic2:
		return m.Topic2()
	case evmevent.FieldTopic2Hex:
		return m.Topic2Hex()
	case evmevent.FieldTopic3:
		return m.Topic3()
	case evmevent.FieldTopic3Hex:
		return m.Topic3Hex()
	case evmevent.FieldData:
		return m.Data()
	case evmevent.FieldDataHex:
		return m.DataHex()
	case evmevent.FieldRemoved:
		return m.Removed()
	case evmevent.FieldStatus:
		return m.Status()
	case evmevent.FieldFailedReason:
		return m.FailedReason()
	case evmevent.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EVMEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case evmevent.FieldTransactionHash:
		return m.OldTransactionHash(ctx)
	case evmevent.FieldTransactionIndex:
		return m.OldTransactionIndex(ctx)
	case evmevent.FieldBlockHash:
		return m.OldBlockHash(ctx)
	case evmevent.FieldBlockNumber:
		return m.OldBlockNumber(ctx)
	case evmevent.FieldLogIndex:
		return m.OldLogIndex(ctx)
	case evmevent.FieldAddress:
		return m.OldAddress(ctx)
	case evmevent.FieldTopic0:
		return m.OldTopic0(ctx)
	case evmevent.FieldTopic0Hex:
		return m.OldTopic0Hex(ctx)
	case evmevent.FieldTopic1:
		return m.OldTopic1(ctx)
	case evmevent.FieldTopic1Hex:
		return m.OldTopic1Hex(ctx)
	case evmevent.FieldTopic2:
		return m.OldTopic2(ctx)
	case evmevent.FieldTopic2Hex:
		return m.OldTopic2Hex(ctx)
	case evmevent.FieldTopic3:
		return m.OldTopic3(ctx)
	case evmevent.FieldTopic3Hex:
		return m.OldTopic3Hex(ctx)
	case evmevent.FieldData:
		return m.OldData(ctx)
	case evmevent.FieldDataHex:
		return m.OldDataHex(ctx)
	case evmevent.FieldRemoved:
		return m.OldRemoved(ctx)
	case evmevent.FieldStatus:
		return m.OldStatus(ctx)
	case evmevent.FieldFailedReason:
		return m.OldFailedReason(ctx)
	case evmevent.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown EVMEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EVMEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case evmevent.FieldTransactionHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionHash(v)
		return nil
	case evmevent.FieldTransactionIndex:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionIndex(v)
		return nil
	case evmevent.FieldBlockHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockHash(v)
		return nil
	case evmevent.FieldBlockNumber:
		v, ok := value.(typeutil.Uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockNumber(v)
		return nil
	case evmevent.FieldLogIndex:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogIndex(v)
		return nil
	case evmevent.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case evmevent.FieldTopic0:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic0(v)
		return nil
	case evmevent.FieldTopic0Hex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic0Hex(v)
		return nil
	case evmevent.FieldTopic1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic1(v)
		return nil
	case evmevent.FieldTopic1Hex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic1Hex(v)
		return nil
	case evmevent.FieldTopic2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic2(v)
		return nil
	case evmevent.FieldTopic2Hex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic2Hex(v)
		return nil
	case evmevent.FieldTopic3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic3(v)
		return nil
	case evmevent.FieldTopic3Hex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic3Hex(v)
		return nil
	case evmevent.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case evmevent.FieldDataHex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataHex(v)
		return nil
	case evmevent.FieldRemoved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoved(v)
		return nil
	case evmevent.FieldStatus:
		v, ok := value.(evmevent.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case evmevent.FieldFailedReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailedReason(v)
		return nil
	case evmevent.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown EVMEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EVMEventMutation) AddedFields() []string {
	var fields []string
	if m.addtransaction_index != nil {
		fields = append(fields, evmevent.FieldTransactionIndex)
	}
	if m.addblock_number != nil {
		fields = append(fields, evmevent.FieldBlockNumber)
	}
	if m.addlog_index != nil {
		fields = append(fields, evmevent.FieldLogIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EVMEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case evmevent.FieldTransactionIndex:
		return m.AddedTransactionIndex()
	case evmevent.FieldBlockNumber:
		return m.AddedBlockNumber()
	case evmevent.FieldLogIndex:
		return m.AddedLogIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EVMEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case evmevent.FieldTransactionIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTransactionIndex(v)
		return nil
	case evmevent.FieldBlockNumber:
		v, ok := value.(typeutil.Uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockNumber(v)
		return nil
	case evmevent.FieldLogIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLogIndex(v)
		return nil
	}
	return fmt.Errorf("unknown EVMEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EVMEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(evmevent.FieldTopic1) {
		fields = append(fields, evmevent.FieldTopic1)
	}
	if m.FieldCleared(evmevent.FieldTopic1Hex) {
		fields = append(fields, evmevent.FieldTopic1Hex)
	}
	if m.FieldCleared(evmevent.FieldTopic2) {
		fields = append(fields, evmevent.FieldTopic2)
	}
	if m.FieldCleared(evmevent.FieldTopic2Hex) {
		fields = append(fields, evmevent.FieldTopic2Hex)
	}
	if m.FieldCleared(evmevent.FieldTopic3) {
		fields = append(fields, evmevent.FieldTopic3)
	}
	if m.FieldCleared(evmevent.FieldTopic3Hex) {
		fields = append(fields, evmevent.FieldTopic3Hex)
	}
	if m.FieldCleared(evmevent.FieldData) {
		fields = append(fields, evmevent.FieldData)
	}
	if m.FieldCleared(evmevent.FieldDataHex) {
		fields = append(fields, evmevent.FieldDataHex)
	}
	if m.FieldCleared(evmevent.FieldFailedReason) {
		fields = append(fields, evmevent.FieldFailedReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EVMEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EVMEventMutation) ClearField(name string) error {
	switch name {
	case evmevent.FieldTopic1:
		m.ClearTopic1()
		return nil
	case evmevent.FieldTopic1Hex:
		m.ClearTopic1Hex()
		return nil
	case evmevent.FieldTopic2:
		m.ClearTopic2()
		return nil
	case evmevent.FieldTopic2Hex:
		m.ClearTopic2Hex()
		return nil
	case evmevent.FieldTopic3:
		m.ClearTopic3()
		return nil
	case evmevent.FieldTopic3Hex:
		m.ClearTopic3Hex()
		return nil
	case evmevent.FieldData:
		m.ClearData()
		return nil
	case evmevent.FieldDataHex:
		m.ClearDataHex()
		return nil
	case evmevent.FieldFailedReason:
		m.ClearFailedReason()
		return nil
	}
	return fmt.Errorf("unknown EVMEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EVMEventMutation) ResetField(name string) error {
	switch name {
	case evmevent.FieldTransactionHash:
		m.ResetTransactionHash()
		return nil
	case evmevent.FieldTransactionIndex:
		m.ResetTransactionIndex()
		return nil
	case evmevent.FieldBlockHash:
		m.ResetBlockHash()
		return nil
	case evmevent.FieldBlockNumber:
		m.ResetBlockNumber()
		return nil
	case evmevent.FieldLogIndex:
		m.ResetLogIndex()
		return nil
	case evmevent.FieldAddress:
		m.ResetAddress()
		return nil
	case evmevent.FieldTopic0:
		m.ResetTopic0()
		return nil
	case evmevent.FieldTopic0Hex:
		m.ResetTopic0Hex()
		return nil
	case evmevent.FieldTopic1:
		m.ResetTopic1()
		return nil
	case evmevent.FieldTopic1Hex:
		m.ResetTopic1Hex()
		return nil
	case evmevent.FieldTopic2:
		m.ResetTopic2()
		return nil
	case evmevent.FieldTopic2Hex:
		m.ResetTopic2Hex()
		return nil
	case evmevent.FieldTopic3:
		m.ResetTopic3()
		return nil
	case evmevent.FieldTopic3Hex:
		m.ResetTopic3Hex()
		return nil
	case evmevent.FieldData:
		m.ResetData()
		return nil
	case evmevent.FieldDataHex:
		m.ResetDataHex()
		return nil
	case evmevent.FieldRemoved:
		m.ResetRemoved()
		return nil
	case evmevent.FieldStatus:
		m.ResetStatus()
		return nil
	case evmevent.FieldFailedReason:
		m.ResetFailedReason()
		return nil
	case evmevent.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown EVMEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EVMEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EVMEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EVMEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EVMEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EVMEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EVMEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EVMEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EVMEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EVMEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EVMEvent edge %s", name)
}

// EVMEventProcessedBlockHeightMutation represents an operation that mutates the EVMEventProcessedBlockHeight nodes in the graph.
type EVMEventProcessedBlockHeightMutation struct {
	config
	op               Op
	typ              string
	id               *int
	contract_type    *evmeventprocessedblockheight.ContractType
	contract_address *string
	event            *evmeventprocessedblockheight.Event
	block_height     *typeutil.Uint64
	addblock_height  *typeutil.Uint64
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*EVMEventProcessedBlockHeight, error)
	predicates       []predicate.EVMEventProcessedBlockHeight
}

var _ ent.Mutation = (*EVMEventProcessedBlockHeightMutation)(nil)

// evmeventprocessedblockheightOption allows management of the mutation configuration using functional options.
type evmeventprocessedblockheightOption func(*EVMEventProcessedBlockHeightMutation)

// newEVMEventProcessedBlockHeightMutation creates new mutation for the EVMEventProcessedBlockHeight entity.
func newEVMEventProcessedBlockHeightMutation(c config, op Op, opts ...evmeventprocessedblockheightOption) *EVMEventProcessedBlockHeightMutation {
	m := &EVMEventProcessedBlockHeightMutation{
		config:        c,
		op:            op,
		typ:           TypeEVMEventProcessedBlockHeight,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEVMEventProcessedBlockHeightID sets the ID field of the mutation.
func withEVMEventProcessedBlockHeightID(id int) evmeventprocessedblockheightOption {
	return func(m *EVMEventProcessedBlockHeightMutation) {
		var (
			err   error
			once  sync.Once
			value *EVMEventProcessedBlockHeight
		)
		m.oldValue = func(ctx context.Context) (*EVMEventProcessedBlockHeight, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EVMEventProcessedBlockHeight.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEVMEventProcessedBlockHeight sets the old EVMEventProcessedBlockHeight of the mutation.
func withEVMEventProcessedBlockHeight(node *EVMEventProcessedBlockHeight) evmeventprocessedblockheightOption {
	return func(m *EVMEventProcessedBlockHeightMutation) {
		m.oldValue = func(context.Context) (*EVMEventProcessedBlockHeight, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EVMEventProcessedBlockHeightMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EVMEventProcessedBlockHeightMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EVMEventProcessedBlockHeightMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EVMEventProcessedBlockHeightMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EVMEventProcessedBlockHeight.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContractType sets the "contract_type" field.
func (m *EVMEventProcessedBlockHeightMutation) SetContractType(et evmeventprocessedblockheight.ContractType) {
	m.contract_type = &et
}

// ContractType returns the value of the "contract_type" field in the mutation.
func (m *EVMEventProcessedBlockHeightMutation) ContractType() (r evmeventprocessedblockheight.ContractType, exists bool) {
	v := m.contract_type
	if v == nil {
		return
	}
	return *v, true
}

// OldContractType returns the old "contract_type" field's value of the EVMEventProcessedBlockHeight entity.
// If the EVMEventProcessedBlockHeight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventProcessedBlockHeightMutation) OldContractType(ctx context.Context) (v evmeventprocessedblockheight.ContractType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractType: %w", err)
	}
	return oldValue.ContractType, nil
}

// ResetContractType resets all changes to the "contract_type" field.
func (m *EVMEventProcessedBlockHeightMutation) ResetContractType() {
	m.contract_type = nil
}

// SetContractAddress sets the "contract_address" field.
func (m *EVMEventProcessedBlockHeightMutation) SetContractAddress(s string) {
	m.contract_address = &s
}

// ContractAddress returns the value of the "contract_address" field in the mutation.
func (m *EVMEventProcessedBlockHeightMutation) ContractAddress() (r string, exists bool) {
	v := m.contract_address
	if v == nil {
		return
	}
	return *v, true
}

// OldContractAddress returns the old "contract_address" field's value of the EVMEventProcessedBlockHeight entity.
// If the EVMEventProcessedBlockHeight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventProcessedBlockHeightMutation) OldContractAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractAddress: %w", err)
	}
	return oldValue.ContractAddress, nil
}

// ResetContractAddress resets all changes to the "contract_address" field.
func (m *EVMEventProcessedBlockHeightMutation) ResetContractAddress() {
	m.contract_address = nil
}

// SetEvent sets the "event" field.
func (m *EVMEventProcessedBlockHeightMutation) SetEvent(e evmeventprocessedblockheight.Event) {
	m.event = &e
}

// Event returns the value of the "event" field in the mutation.
func (m *EVMEventProcessedBlockHeightMutation) Event() (r evmeventprocessedblockheight.Event, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEvent returns the old "event" field's value of the EVMEventProcessedBlockHeight entity.
// If the EVMEventProcessedBlockHeight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventProcessedBlockHeightMutation) OldEvent(ctx context.Context) (v evmeventprocessedblockheight.Event, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvent: %w", err)
	}
	return oldValue.Event, nil
}

// ResetEvent resets all changes to the "event" field.
func (m *EVMEventProcessedBlockHeightMutation) ResetEvent() {
	m.event = nil
}

// SetBlockHeight sets the "block_height" field.
func (m *EVMEventProcessedBlockHeightMutation) SetBlockHeight(t typeutil.Uint64) {
	m.block_height = &t
	m.addblock_height = nil
}

// BlockHeight returns the value of the "block_height" field in the mutation.
func (m *EVMEventProcessedBlockHeightMutation) BlockHeight() (r typeutil.Uint64, exists bool) {
	v := m.block_height
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockHeight returns the old "block_height" field's value of the EVMEventProcessedBlockHeight entity.
// If the EVMEventProcessedBlockHeight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventProcessedBlockHeightMutation) OldBlockHeight(ctx context.Context) (v typeutil.Uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockHeight: %w", err)
	}
	return oldValue.BlockHeight, nil
}

// AddBlockHeight adds t to the "block_height" field.
func (m *EVMEventProcessedBlockHeightMutation) AddBlockHeight(t typeutil.Uint64) {
	if m.addblock_height != nil {
		*m.addblock_height += t
	} else {
		m.addblock_height = &t
	}
}

// AddedBlockHeight returns the value that was added to the "block_height" field in this mutation.
func (m *EVMEventProcessedBlockHeightMutation) AddedBlockHeight() (r typeutil.Uint64, exists bool) {
	v := m.addblock_height
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockHeight resets all changes to the "block_height" field.
func (m *EVMEventProcessedBlockHeightMutation) ResetBlockHeight() {
	m.block_height = nil
	m.addblock_height = nil
}

// Where appends a list predicates to the EVMEventProcessedBlockHeightMutation builder.
func (m *EVMEventProcessedBlockHeightMutation) Where(ps ...predicate.EVMEventProcessedBlockHeight) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EVMEventProcessedBlockHeightMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EVMEventProcessedBlockHeightMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EVMEventProcessedBlockHeight, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EVMEventProcessedBlockHeightMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EVMEventProcessedBlockHeightMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EVMEventProcessedBlockHeight).
func (m *EVMEventProcessedBlockHeightMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EVMEventProcessedBlockHeightMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.contract_type != nil {
		fields = append(fields, evmeventprocessedblockheight.FieldContractType)
	}
	if m.contract_address != nil {
		fields = append(fields, evmeventprocessedblockheight.FieldContractAddress)
	}
	if m.event != nil {
		fields = append(fields, evmeventprocessedblockheight.FieldEvent)
	}
	if m.block_height != nil {
		fields = append(fields, evmeventprocessedblockheight.FieldBlockHeight)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EVMEventProcessedBlockHeightMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case evmeventprocessedblockheight.FieldContractType:
		return m.ContractType()
	case evmeventprocessedblockheight.FieldContractAddress:
		return m.ContractAddress()
	case evmeventprocessedblockheight.FieldEvent:
		return m.Event()
	case evmeventprocessedblockheight.FieldBlockHeight:
		return m.BlockHeight()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EVMEventProcessedBlockHeightMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case evmeventprocessedblockheight.FieldContractType:
		return m.OldContractType(ctx)
	case evmeventprocessedblockheight.FieldContractAddress:
		return m.OldContractAddress(ctx)
	case evmeventprocessedblockheight.FieldEvent:
		return m.OldEvent(ctx)
	case evmeventprocessedblockheight.FieldBlockHeight:
		return m.OldBlockHeight(ctx)
	}
	return nil, fmt.Errorf("unknown EVMEventProcessedBlockHeight field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EVMEventProcessedBlockHeightMutation) SetField(name string, value ent.Value) error {
	switch name {
	case evmeventprocessedblockheight.FieldContractType:
		v, ok := value.(evmeventprocessedblockheight.ContractType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractType(v)
		return nil
	case evmeventprocessedblockheight.FieldContractAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractAddress(v)
		return nil
	case evmeventprocessedblockheight.FieldEvent:
		v, ok := value.(evmeventprocessedblockheight.Event)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvent(v)
		return nil
	case evmeventprocessedblockheight.FieldBlockHeight:
		v, ok := value.(typeutil.Uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockHeight(v)
		return nil
	}
	return fmt.Errorf("unknown EVMEventProcessedBlockHeight field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EVMEventProcessedBlockHeightMutation) AddedFields() []string {
	var fields []string
	if m.addblock_height != nil {
		fields = append(fields, evmeventprocessedblockheight.FieldBlockHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EVMEventProcessedBlockHeightMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case evmeventprocessedblockheight.FieldBlockHeight:
		return m.AddedBlockHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EVMEventProcessedBlockHeightMutation) AddField(name string, value ent.Value) error {
	switch name {
	case evmeventprocessedblockheight.FieldBlockHeight:
		v, ok := value.(typeutil.Uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockHeight(v)
		return nil
	}
	return fmt.Errorf("unknown EVMEventProcessedBlockHeight numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EVMEventProcessedBlockHeightMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EVMEventProcessedBlockHeightMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EVMEventProcessedBlockHeightMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EVMEventProcessedBlockHeight nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EVMEventProcessedBlockHeightMutation) ResetField(name string) error {
	switch name {
	case evmeventprocessedblockheight.FieldContractType:
		m.ResetContractType()
		return nil
	case evmeventprocessedblockheight.FieldContractAddress:
		m.ResetContractAddress()
		return nil
	case evmeventprocessedblockheight.FieldEvent:
		m.ResetEvent()
		return nil
	case evmeventprocessedblockheight.FieldBlockHeight:
		m.ResetBlockHeight()
		return nil
	}
	return fmt.Errorf("unknown EVMEventProcessedBlockHeight field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EVMEventProcessedBlockHeightMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EVMEventProcessedBlockHeightMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EVMEventProcessedBlockHeightMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EVMEventProcessedBlockHeightMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EVMEventProcessedBlockHeightMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EVMEventProcessedBlockHeightMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EVMEventProcessedBlockHeightMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EVMEventProcessedBlockHeight unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EVMEventProcessedBlockHeightMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EVMEventProcessedBlockHeight edge %s", name)
}

// NFTMutation represents an operation that mutates the NFT nodes in the graph.
type NFTMutation struct {
	config
	op               Op
	typ              string
	id               *int
	contract_address *string
	token_id         *typeutil.Uint64
	addtoken_id      *typeutil.Uint64
	token_uri        *string
	image            *string
	image_data       *string
	external_url     *string
	description      *string
	name             *string
	attributes       *[]model.ERC721MetadataAttribute
	appendattributes []model.ERC721MetadataAttribute
	background_color *string
	animation_url    *string
	youtube_url      *string
	owner_address    *string
	minted_at        *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	owner            *int
	clearedowner     bool
	class            *int
	clearedclass     bool
	done             bool
	oldValue         func(context.Context) (*NFT, error)
	predicates       []predicate.NFT
}

var _ ent.Mutation = (*NFTMutation)(nil)

// nftOption allows management of the mutation configuration using functional options.
type nftOption func(*NFTMutation)

// newNFTMutation creates new mutation for the NFT entity.
func newNFTMutation(c config, op Op, opts ...nftOption) *NFTMutation {
	m := &NFTMutation{
		config:        c,
		op:            op,
		typ:           TypeNFT,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNFTID sets the ID field of the mutation.
func withNFTID(id int) nftOption {
	return func(m *NFTMutation) {
		var (
			err   error
			once  sync.Once
			value *NFT
		)
		m.oldValue = func(ctx context.Context) (*NFT, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NFT.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNFT sets the old NFT of the mutation.
func withNFT(node *NFT) nftOption {
	return func(m *NFTMutation) {
		m.oldValue = func(context.Context) (*NFT, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NFTMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NFTMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NFTMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NFTMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NFT.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContractAddress sets the "contract_address" field.
func (m *NFTMutation) SetContractAddress(s string) {
	m.contract_address = &s
}

// ContractAddress returns the value of the "contract_address" field in the mutation.
func (m *NFTMutation) ContractAddress() (r string, exists bool) {
	v := m.contract_address
	if v == nil {
		return
	}
	return *v, true
}

// OldContractAddress returns the old "contract_address" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldContractAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractAddress: %w", err)
	}
	return oldValue.ContractAddress, nil
}

// ResetContractAddress resets all changes to the "contract_address" field.
func (m *NFTMutation) ResetContractAddress() {
	m.contract_address = nil
}

// SetTokenID sets the "token_id" field.
func (m *NFTMutation) SetTokenID(t typeutil.Uint64) {
	m.token_id = &t
	m.addtoken_id = nil
}

// TokenID returns the value of the "token_id" field in the mutation.
func (m *NFTMutation) TokenID() (r typeutil.Uint64, exists bool) {
	v := m.token_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenID returns the old "token_id" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldTokenID(ctx context.Context) (v typeutil.Uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenID: %w", err)
	}
	return oldValue.TokenID, nil
}

// AddTokenID adds t to the "token_id" field.
func (m *NFTMutation) AddTokenID(t typeutil.Uint64) {
	if m.addtoken_id != nil {
		*m.addtoken_id += t
	} else {
		m.addtoken_id = &t
	}
}

// AddedTokenID returns the value that was added to the "token_id" field in this mutation.
func (m *NFTMutation) AddedTokenID() (r typeutil.Uint64, exists bool) {
	v := m.addtoken_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTokenID resets all changes to the "token_id" field.
func (m *NFTMutation) ResetTokenID() {
	m.token_id = nil
	m.addtoken_id = nil
}

// SetTokenURI sets the "token_uri" field.
func (m *NFTMutation) SetTokenURI(s string) {
	m.token_uri = &s
}

// TokenURI returns the value of the "token_uri" field in the mutation.
func (m *NFTMutation) TokenURI() (r string, exists bool) {
	v := m.token_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenURI returns the old "token_uri" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldTokenURI(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenURI: %w", err)
	}
	return oldValue.TokenURI, nil
}

// ClearTokenURI clears the value of the "token_uri" field.
func (m *NFTMutation) ClearTokenURI() {
	m.token_uri = nil
	m.clearedFields[nft.FieldTokenURI] = struct{}{}
}

// TokenURICleared returns if the "token_uri" field was cleared in this mutation.
func (m *NFTMutation) TokenURICleared() bool {
	_, ok := m.clearedFields[nft.FieldTokenURI]
	return ok
}

// ResetTokenURI resets all changes to the "token_uri" field.
func (m *NFTMutation) ResetTokenURI() {
	m.token_uri = nil
	delete(m.clearedFields, nft.FieldTokenURI)
}

// SetImage sets the "image" field.
func (m *NFTMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *NFTMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldImage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *NFTMutation) ClearImage() {
	m.image = nil
	m.clearedFields[nft.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *NFTMutation) ImageCleared() bool {
	_, ok := m.clearedFields[nft.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *NFTMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, nft.FieldImage)
}

// SetImageData sets the "image_data" field.
func (m *NFTMutation) SetImageData(s string) {
	m.image_data = &s
}

// ImageData returns the value of the "image_data" field in the mutation.
func (m *NFTMutation) ImageData() (r string, exists bool) {
	v := m.image_data
	if v == nil {
		return
	}
	return *v, true
}

// OldImageData returns the old "image_data" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldImageData(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageData: %w", err)
	}
	return oldValue.ImageData, nil
}

// ClearImageData clears the value of the "image_data" field.
func (m *NFTMutation) ClearImageData() {
	m.image_data = nil
	m.clearedFields[nft.FieldImageData] = struct{}{}
}

// ImageDataCleared returns if the "image_data" field was cleared in this mutation.
func (m *NFTMutation) ImageDataCleared() bool {
	_, ok := m.clearedFields[nft.FieldImageData]
	return ok
}

// ResetImageData resets all changes to the "image_data" field.
func (m *NFTMutation) ResetImageData() {
	m.image_data = nil
	delete(m.clearedFields, nft.FieldImageData)
}

// SetExternalURL sets the "external_url" field.
func (m *NFTMutation) SetExternalURL(s string) {
	m.external_url = &s
}

// ExternalURL returns the value of the "external_url" field in the mutation.
func (m *NFTMutation) ExternalURL() (r string, exists bool) {
	v := m.external_url
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalURL returns the old "external_url" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldExternalURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalURL: %w", err)
	}
	return oldValue.ExternalURL, nil
}

// ClearExternalURL clears the value of the "external_url" field.
func (m *NFTMutation) ClearExternalURL() {
	m.external_url = nil
	m.clearedFields[nft.FieldExternalURL] = struct{}{}
}

// ExternalURLCleared returns if the "external_url" field was cleared in this mutation.
func (m *NFTMutation) ExternalURLCleared() bool {
	_, ok := m.clearedFields[nft.FieldExternalURL]
	return ok
}

// ResetExternalURL resets all changes to the "external_url" field.
func (m *NFTMutation) ResetExternalURL() {
	m.external_url = nil
	delete(m.clearedFields, nft.FieldExternalURL)
}

// SetDescription sets the "description" field.
func (m *NFTMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NFTMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *NFTMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[nft.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *NFTMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[nft.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *NFTMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, nft.FieldDescription)
}

// SetName sets the "name" field.
func (m *NFTMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NFTMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *NFTMutation) ClearName() {
	m.name = nil
	m.clearedFields[nft.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *NFTMutation) NameCleared() bool {
	_, ok := m.clearedFields[nft.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *NFTMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, nft.FieldName)
}

// SetAttributes sets the "attributes" field.
func (m *NFTMutation) SetAttributes(ma []model.ERC721MetadataAttribute) {
	m.attributes = &ma
	m.appendattributes = nil
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *NFTMutation) Attributes() (r []model.ERC721MetadataAttribute, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldAttributes(ctx context.Context) (v []model.ERC721MetadataAttribute, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// AppendAttributes adds ma to the "attributes" field.
func (m *NFTMutation) AppendAttributes(ma []model.ERC721MetadataAttribute) {
	m.appendattributes = append(m.appendattributes, ma...)
}

// AppendedAttributes returns the list of values that were appended to the "attributes" field in this mutation.
func (m *NFTMutation) AppendedAttributes() ([]model.ERC721MetadataAttribute, bool) {
	if len(m.appendattributes) == 0 {
		return nil, false
	}
	return m.appendattributes, true
}

// ClearAttributes clears the value of the "attributes" field.
func (m *NFTMutation) ClearAttributes() {
	m.attributes = nil
	m.appendattributes = nil
	m.clearedFields[nft.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *NFTMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[nft.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *NFTMutation) ResetAttributes() {
	m.attributes = nil
	m.appendattributes = nil
	delete(m.clearedFields, nft.FieldAttributes)
}

// SetBackgroundColor sets the "background_color" field.
func (m *NFTMutation) SetBackgroundColor(s string) {
	m.background_color = &s
}

// BackgroundColor returns the value of the "background_color" field in the mutation.
func (m *NFTMutation) BackgroundColor() (r string, exists bool) {
	v := m.background_color
	if v == nil {
		return
	}
	return *v, true
}

// OldBackgroundColor returns the old "background_color" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldBackgroundColor(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackgroundColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackgroundColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackgroundColor: %w", err)
	}
	return oldValue.BackgroundColor, nil
}

// ClearBackgroundColor clears the value of the "background_color" field.
func (m *NFTMutation) ClearBackgroundColor() {
	m.background_color = nil
	m.clearedFields[nft.FieldBackgroundColor] = struct{}{}
}

// BackgroundColorCleared returns if the "background_color" field was cleared in this mutation.
func (m *NFTMutation) BackgroundColorCleared() bool {
	_, ok := m.clearedFields[nft.FieldBackgroundColor]
	return ok
}

// ResetBackgroundColor resets all changes to the "background_color" field.
func (m *NFTMutation) ResetBackgroundColor() {
	m.background_color = nil
	delete(m.clearedFields, nft.FieldBackgroundColor)
}

// SetAnimationURL sets the "animation_url" field.
func (m *NFTMutation) SetAnimationURL(s string) {
	m.animation_url = &s
}

// AnimationURL returns the value of the "animation_url" field in the mutation.
func (m *NFTMutation) AnimationURL() (r string, exists bool) {
	v := m.animation_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAnimationURL returns the old "animation_url" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldAnimationURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnimationURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnimationURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnimationURL: %w", err)
	}
	return oldValue.AnimationURL, nil
}

// ClearAnimationURL clears the value of the "animation_url" field.
func (m *NFTMutation) ClearAnimationURL() {
	m.animation_url = nil
	m.clearedFields[nft.FieldAnimationURL] = struct{}{}
}

// AnimationURLCleared returns if the "animation_url" field was cleared in this mutation.
func (m *NFTMutation) AnimationURLCleared() bool {
	_, ok := m.clearedFields[nft.FieldAnimationURL]
	return ok
}

// ResetAnimationURL resets all changes to the "animation_url" field.
func (m *NFTMutation) ResetAnimationURL() {
	m.animation_url = nil
	delete(m.clearedFields, nft.FieldAnimationURL)
}

// SetYoutubeURL sets the "youtube_url" field.
func (m *NFTMutation) SetYoutubeURL(s string) {
	m.youtube_url = &s
}

// YoutubeURL returns the value of the "youtube_url" field in the mutation.
func (m *NFTMutation) YoutubeURL() (r string, exists bool) {
	v := m.youtube_url
	if v == nil {
		return
	}
	return *v, true
}

// OldYoutubeURL returns the old "youtube_url" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldYoutubeURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYoutubeURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYoutubeURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYoutubeURL: %w", err)
	}
	return oldValue.YoutubeURL, nil
}

// ClearYoutubeURL clears the value of the "youtube_url" field.
func (m *NFTMutation) ClearYoutubeURL() {
	m.youtube_url = nil
	m.clearedFields[nft.FieldYoutubeURL] = struct{}{}
}

// YoutubeURLCleared returns if the "youtube_url" field was cleared in this mutation.
func (m *NFTMutation) YoutubeURLCleared() bool {
	_, ok := m.clearedFields[nft.FieldYoutubeURL]
	return ok
}

// ResetYoutubeURL resets all changes to the "youtube_url" field.
func (m *NFTMutation) ResetYoutubeURL() {
	m.youtube_url = nil
	delete(m.clearedFields, nft.FieldYoutubeURL)
}

// SetOwnerAddress sets the "owner_address" field.
func (m *NFTMutation) SetOwnerAddress(s string) {
	m.owner_address = &s
}

// OwnerAddress returns the value of the "owner_address" field in the mutation.
func (m *NFTMutation) OwnerAddress() (r string, exists bool) {
	v := m.owner_address
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerAddress returns the old "owner_address" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldOwnerAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerAddress: %w", err)
	}
	return oldValue.OwnerAddress, nil
}

// ResetOwnerAddress resets all changes to the "owner_address" field.
func (m *NFTMutation) ResetOwnerAddress() {
	m.owner_address = nil
}

// SetMintedAt sets the "minted_at" field.
func (m *NFTMutation) SetMintedAt(t time.Time) {
	m.minted_at = &t
}

// MintedAt returns the value of the "minted_at" field in the mutation.
func (m *NFTMutation) MintedAt() (r time.Time, exists bool) {
	v := m.minted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldMintedAt returns the old "minted_at" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldMintedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMintedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMintedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMintedAt: %w", err)
	}
	return oldValue.MintedAt, nil
}

// ResetMintedAt resets all changes to the "minted_at" field.
func (m *NFTMutation) ResetMintedAt() {
	m.minted_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NFTMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NFTMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NFTMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the Account entity by id.
func (m *NFTMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Account entity.
func (m *NFTMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Account entity was cleared.
func (m *NFTMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NFTMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NFTMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NFTMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetClassID sets the "class" edge to the NFTClass entity by id.
func (m *NFTMutation) SetClassID(id int) {
	m.class = &id
}

// ClearClass clears the "class" edge to the NFTClass entity.
func (m *NFTMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the NFTClass entity was cleared.
func (m *NFTMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *NFTMutation) ClassID() (id int, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *NFTMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *NFTMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// Where appends a list predicates to the NFTMutation builder.
func (m *NFTMutation) Where(ps ...predicate.NFT) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NFTMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NFTMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NFT, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NFTMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NFTMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NFT).
func (m *NFTMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NFTMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.contract_address != nil {
		fields = append(fields, nft.FieldContractAddress)
	}
	if m.token_id != nil {
		fields = append(fields, nft.FieldTokenID)
	}
	if m.token_uri != nil {
		fields = append(fields, nft.FieldTokenURI)
	}
	if m.image != nil {
		fields = append(fields, nft.FieldImage)
	}
	if m.image_data != nil {
		fields = append(fields, nft.FieldImageData)
	}
	if m.external_url != nil {
		fields = append(fields, nft.FieldExternalURL)
	}
	if m.description != nil {
		fields = append(fields, nft.FieldDescription)
	}
	if m.name != nil {
		fields = append(fields, nft.FieldName)
	}
	if m.attributes != nil {
		fields = append(fields, nft.FieldAttributes)
	}
	if m.background_color != nil {
		fields = append(fields, nft.FieldBackgroundColor)
	}
	if m.animation_url != nil {
		fields = append(fields, nft.FieldAnimationURL)
	}
	if m.youtube_url != nil {
		fields = append(fields, nft.FieldYoutubeURL)
	}
	if m.owner_address != nil {
		fields = append(fields, nft.FieldOwnerAddress)
	}
	if m.minted_at != nil {
		fields = append(fields, nft.FieldMintedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, nft.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NFTMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nft.FieldContractAddress:
		return m.ContractAddress()
	case nft.FieldTokenID:
		return m.TokenID()
	case nft.FieldTokenURI:
		return m.TokenURI()
	case nft.FieldImage:
		return m.Image()
	case nft.FieldImageData:
		return m.ImageData()
	case nft.FieldExternalURL:
		return m.ExternalURL()
	case nft.FieldDescription:
		return m.Description()
	case nft.FieldName:
		return m.Name()
	case nft.FieldAttributes:
		return m.Attributes()
	case nft.FieldBackgroundColor:
		return m.BackgroundColor()
	case nft.FieldAnimationURL:
		return m.AnimationURL()
	case nft.FieldYoutubeURL:
		return m.YoutubeURL()
	case nft.FieldOwnerAddress:
		return m.OwnerAddress()
	case nft.FieldMintedAt:
		return m.MintedAt()
	case nft.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NFTMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nft.FieldContractAddress:
		return m.OldContractAddress(ctx)
	case nft.FieldTokenID:
		return m.OldTokenID(ctx)
	case nft.FieldTokenURI:
		return m.OldTokenURI(ctx)
	case nft.FieldImage:
		return m.OldImage(ctx)
	case nft.FieldImageData:
		return m.OldImageData(ctx)
	case nft.FieldExternalURL:
		return m.OldExternalURL(ctx)
	case nft.FieldDescription:
		return m.OldDescription(ctx)
	case nft.FieldName:
		return m.OldName(ctx)
	case nft.FieldAttributes:
		return m.OldAttributes(ctx)
	case nft.FieldBackgroundColor:
		return m.OldBackgroundColor(ctx)
	case nft.FieldAnimationURL:
		return m.OldAnimationURL(ctx)
	case nft.FieldYoutubeURL:
		return m.OldYoutubeURL(ctx)
	case nft.FieldOwnerAddress:
		return m.OldOwnerAddress(ctx)
	case nft.FieldMintedAt:
		return m.OldMintedAt(ctx)
	case nft.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NFT field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NFTMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nft.FieldContractAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractAddress(v)
		return nil
	case nft.FieldTokenID:
		v, ok := value.(typeutil.Uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenID(v)
		return nil
	case nft.FieldTokenURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenURI(v)
		return nil
	case nft.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case nft.FieldImageData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageData(v)
		return nil
	case nft.FieldExternalURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalURL(v)
		return nil
	case nft.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case nft.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case nft.FieldAttributes:
		v, ok := value.([]model.ERC721MetadataAttribute)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	case nft.FieldBackgroundColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackgroundColor(v)
		return nil
	case nft.FieldAnimationURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnimationURL(v)
		return nil
	case nft.FieldYoutubeURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYoutubeURL(v)
		return nil
	case nft.FieldOwnerAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerAddress(v)
		return nil
	case nft.FieldMintedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMintedAt(v)
		return nil
	case nft.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NFT field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NFTMutation) AddedFields() []string {
	var fields []string
	if m.addtoken_id != nil {
		fields = append(fields, nft.FieldTokenID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NFTMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case nft.FieldTokenID:
		return m.AddedTokenID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NFTMutation) AddField(name string, value ent.Value) error {
	switch name {
	case nft.FieldTokenID:
		v, ok := value.(typeutil.Uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokenID(v)
		return nil
	}
	return fmt.Errorf("unknown NFT numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NFTMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(nft.FieldTokenURI) {
		fields = append(fields, nft.FieldTokenURI)
	}
	if m.FieldCleared(nft.FieldImage) {
		fields = append(fields, nft.FieldImage)
	}
	if m.FieldCleared(nft.FieldImageData) {
		fields = append(fields, nft.FieldImageData)
	}
	if m.FieldCleared(nft.FieldExternalURL) {
		fields = append(fields, nft.FieldExternalURL)
	}
	if m.FieldCleared(nft.FieldDescription) {
		fields = append(fields, nft.FieldDescription)
	}
	if m.FieldCleared(nft.FieldName) {
		fields = append(fields, nft.FieldName)
	}
	if m.FieldCleared(nft.FieldAttributes) {
		fields = append(fields, nft.FieldAttributes)
	}
	if m.FieldCleared(nft.FieldBackgroundColor) {
		fields = append(fields, nft.FieldBackgroundColor)
	}
	if m.FieldCleared(nft.FieldAnimationURL) {
		fields = append(fields, nft.FieldAnimationURL)
	}
	if m.FieldCleared(nft.FieldYoutubeURL) {
		fields = append(fields, nft.FieldYoutubeURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NFTMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NFTMutation) ClearField(name string) error {
	switch name {
	case nft.FieldTokenURI:
		m.ClearTokenURI()
		return nil
	case nft.FieldImage:
		m.ClearImage()
		return nil
	case nft.FieldImageData:
		m.ClearImageData()
		return nil
	case nft.FieldExternalURL:
		m.ClearExternalURL()
		return nil
	case nft.FieldDescription:
		m.ClearDescription()
		return nil
	case nft.FieldName:
		m.ClearName()
		return nil
	case nft.FieldAttributes:
		m.ClearAttributes()
		return nil
	case nft.FieldBackgroundColor:
		m.ClearBackgroundColor()
		return nil
	case nft.FieldAnimationURL:
		m.ClearAnimationURL()
		return nil
	case nft.FieldYoutubeURL:
		m.ClearYoutubeURL()
		return nil
	}
	return fmt.Errorf("unknown NFT nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NFTMutation) ResetField(name string) error {
	switch name {
	case nft.FieldContractAddress:
		m.ResetContractAddress()
		return nil
	case nft.FieldTokenID:
		m.ResetTokenID()
		return nil
	case nft.FieldTokenURI:
		m.ResetTokenURI()
		return nil
	case nft.FieldImage:
		m.ResetImage()
		return nil
	case nft.FieldImageData:
		m.ResetImageData()
		return nil
	case nft.FieldExternalURL:
		m.ResetExternalURL()
		return nil
	case nft.FieldDescription:
		m.ResetDescription()
		return nil
	case nft.FieldName:
		m.ResetName()
		return nil
	case nft.FieldAttributes:
		m.ResetAttributes()
		return nil
	case nft.FieldBackgroundColor:
		m.ResetBackgroundColor()
		return nil
	case nft.FieldAnimationURL:
		m.ResetAnimationURL()
		return nil
	case nft.FieldYoutubeURL:
		m.ResetYoutubeURL()
		return nil
	case nft.FieldOwnerAddress:
		m.ResetOwnerAddress()
		return nil
	case nft.FieldMintedAt:
		m.ResetMintedAt()
		return nil
	case nft.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown NFT field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NFTMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, nft.EdgeOwner)
	}
	if m.class != nil {
		edges = append(edges, nft.EdgeClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NFTMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nft.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case nft.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NFTMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NFTMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NFTMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, nft.EdgeOwner)
	}
	if m.clearedclass {
		edges = append(edges, nft.EdgeClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NFTMutation) EdgeCleared(name string) bool {
	switch name {
	case nft.EdgeOwner:
		return m.clearedowner
	case nft.EdgeClass:
		return m.clearedclass
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NFTMutation) ClearEdge(name string) error {
	switch name {
	case nft.EdgeOwner:
		m.ClearOwner()
		return nil
	case nft.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown NFT unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NFTMutation) ResetEdge(name string) error {
	switch name {
	case nft.EdgeOwner:
		m.ResetOwner()
		return nil
	case nft.EdgeClass:
		m.ResetClass()
		return nil
	}
	return fmt.Errorf("unknown NFT edge %s", name)
}

// NFTClassMutation represents an operation that mutates the NFTClass nodes in the graph.
type NFTClassMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	address                  *string
	name                     *string
	symbol                   *string
	owner_address            *string
	minter_addresses         *[]string
	appendminter_addresses   []string
	total_supply             **big.Int
	max_supply               *typeutil.Uint64
	addmax_supply            *typeutil.Uint64
	metadata                 **model.ContractLevelMetadata
	banner_image             *string
	featured_image           *string
	deployer_address         *string
	deployed_block_number    *typeutil.Uint64
	adddeployed_block_number *typeutil.Uint64
	minted_at                *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	nfts                     map[int]struct{}
	removednfts              map[int]struct{}
	clearednfts              bool
	owner                    *int
	clearedowner             bool
	done                     bool
	oldValue                 func(context.Context) (*NFTClass, error)
	predicates               []predicate.NFTClass
}

var _ ent.Mutation = (*NFTClassMutation)(nil)

// nftclassOption allows management of the mutation configuration using functional options.
type nftclassOption func(*NFTClassMutation)

// newNFTClassMutation creates new mutation for the NFTClass entity.
func newNFTClassMutation(c config, op Op, opts ...nftclassOption) *NFTClassMutation {
	m := &NFTClassMutation{
		config:        c,
		op:            op,
		typ:           TypeNFTClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNFTClassID sets the ID field of the mutation.
func withNFTClassID(id int) nftclassOption {
	return func(m *NFTClassMutation) {
		var (
			err   error
			once  sync.Once
			value *NFTClass
		)
		m.oldValue = func(ctx context.Context) (*NFTClass, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NFTClass.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNFTClass sets the old NFTClass of the mutation.
func withNFTClass(node *NFTClass) nftclassOption {
	return func(m *NFTClassMutation) {
		m.oldValue = func(context.Context) (*NFTClass, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NFTClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NFTClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NFTClassMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NFTClassMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NFTClass.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAddress sets the "address" field.
func (m *NFTClassMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *NFTClassMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *NFTClassMutation) ResetAddress() {
	m.address = nil
}

// SetName sets the "name" field.
func (m *NFTClassMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NFTClassMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NFTClassMutation) ResetName() {
	m.name = nil
}

// SetSymbol sets the "symbol" field.
func (m *NFTClassMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *NFTClassMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *NFTClassMutation) ResetSymbol() {
	m.symbol = nil
}

// SetOwnerAddress sets the "owner_address" field.
func (m *NFTClassMutation) SetOwnerAddress(s string) {
	m.owner_address = &s
}

// OwnerAddress returns the value of the "owner_address" field in the mutation.
func (m *NFTClassMutation) OwnerAddress() (r string, exists bool) {
	v := m.owner_address
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerAddress returns the old "owner_address" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldOwnerAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerAddress: %w", err)
	}
	return oldValue.OwnerAddress, nil
}

// ClearOwnerAddress clears the value of the "owner_address" field.
func (m *NFTClassMutation) ClearOwnerAddress() {
	m.owner_address = nil
	m.clearedFields[nftclass.FieldOwnerAddress] = struct{}{}
}

// OwnerAddressCleared returns if the "owner_address" field was cleared in this mutation.
func (m *NFTClassMutation) OwnerAddressCleared() bool {
	_, ok := m.clearedFields[nftclass.FieldOwnerAddress]
	return ok
}

// ResetOwnerAddress resets all changes to the "owner_address" field.
func (m *NFTClassMutation) ResetOwnerAddress() {
	m.owner_address = nil
	delete(m.clearedFields, nftclass.FieldOwnerAddress)
}

// SetMinterAddresses sets the "minter_addresses" field.
func (m *NFTClassMutation) SetMinterAddresses(s []string) {
	m.minter_addresses = &s
	m.appendminter_addresses = nil
}

// MinterAddresses returns the value of the "minter_addresses" field in the mutation.
func (m *NFTClassMutation) MinterAddresses() (r []string, exists bool) {
	v := m.minter_addresses
	if v == nil {
		return
	}
	return *v, true
}

// OldMinterAddresses returns the old "minter_addresses" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldMinterAddresses(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinterAddresses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinterAddresses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinterAddresses: %w", err)
	}
	return oldValue.MinterAddresses, nil
}

// AppendMinterAddresses adds s to the "minter_addresses" field.
func (m *NFTClassMutation) AppendMinterAddresses(s []string) {
	m.appendminter_addresses = append(m.appendminter_addresses, s...)
}

// AppendedMinterAddresses returns the list of values that were appended to the "minter_addresses" field in this mutation.
func (m *NFTClassMutation) AppendedMinterAddresses() ([]string, bool) {
	if len(m.appendminter_addresses) == 0 {
		return nil, false
	}
	return m.appendminter_addresses, true
}

// ClearMinterAddresses clears the value of the "minter_addresses" field.
func (m *NFTClassMutation) ClearMinterAddresses() {
	m.minter_addresses = nil
	m.appendminter_addresses = nil
	m.clearedFields[nftclass.FieldMinterAddresses] = struct{}{}
}

// MinterAddressesCleared returns if the "minter_addresses" field was cleared in this mutation.
func (m *NFTClassMutation) MinterAddressesCleared() bool {
	_, ok := m.clearedFields[nftclass.FieldMinterAddresses]
	return ok
}

// ResetMinterAddresses resets all changes to the "minter_addresses" field.
func (m *NFTClassMutation) ResetMinterAddresses() {
	m.minter_addresses = nil
	m.appendminter_addresses = nil
	delete(m.clearedFields, nftclass.FieldMinterAddresses)
}

// SetTotalSupply sets the "total_supply" field.
func (m *NFTClassMutation) SetTotalSupply(b *big.Int) {
	m.total_supply = &b
}

// TotalSupply returns the value of the "total_supply" field in the mutation.
func (m *NFTClassMutation) TotalSupply() (r *big.Int, exists bool) {
	v := m.total_supply
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSupply returns the old "total_supply" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldTotalSupply(ctx context.Context) (v *big.Int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSupply is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSupply requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSupply: %w", err)
	}
	return oldValue.TotalSupply, nil
}

// ResetTotalSupply resets all changes to the "total_supply" field.
func (m *NFTClassMutation) ResetTotalSupply() {
	m.total_supply = nil
}

// SetMaxSupply sets the "max_supply" field.
func (m *NFTClassMutation) SetMaxSupply(t typeutil.Uint64) {
	m.max_supply = &t
	m.addmax_supply = nil
}

// MaxSupply returns the value of the "max_supply" field in the mutation.
func (m *NFTClassMutation) MaxSupply() (r typeutil.Uint64, exists bool) {
	v := m.max_supply
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxSupply returns the old "max_supply" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldMaxSupply(ctx context.Context) (v typeutil.Uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxSupply is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxSupply requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxSupply: %w", err)
	}
	return oldValue.MaxSupply, nil
}

// AddMaxSupply adds t to the "max_supply" field.
func (m *NFTClassMutation) AddMaxSupply(t typeutil.Uint64) {
	if m.addmax_supply != nil {
		*m.addmax_supply += t
	} else {
		m.addmax_supply = &t
	}
}

// AddedMaxSupply returns the value that was added to the "max_supply" field in this mutation.
func (m *NFTClassMutation) AddedMaxSupply() (r typeutil.Uint64, exists bool) {
	v := m.addmax_supply
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxSupply resets all changes to the "max_supply" field.
func (m *NFTClassMutation) ResetMaxSupply() {
	m.max_supply = nil
	m.addmax_supply = nil
}

// SetMetadata sets the "metadata" field.
func (m *NFTClassMutation) SetMetadata(mlm *model.ContractLevelMetadata) {
	m.metadata = &mlm
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *NFTClassMutation) Metadata() (r *model.ContractLevelMetadata, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldMetadata(ctx context.Context) (v *model.ContractLevelMetadata, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *NFTClassMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[nftclass.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *NFTClassMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[nftclass.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *NFTClassMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, nftclass.FieldMetadata)
}

// SetBannerImage sets the "banner_image" field.
func (m *NFTClassMutation) SetBannerImage(s string) {
	m.banner_image = &s
}

// BannerImage returns the value of the "banner_image" field in the mutation.
func (m *NFTClassMutation) BannerImage() (r string, exists bool) {
	v := m.banner_image
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerImage returns the old "banner_image" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldBannerImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBannerImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBannerImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerImage: %w", err)
	}
	return oldValue.BannerImage, nil
}

// ResetBannerImage resets all changes to the "banner_image" field.
func (m *NFTClassMutation) ResetBannerImage() {
	m.banner_image = nil
}

// SetFeaturedImage sets the "featured_image" field.
func (m *NFTClassMutation) SetFeaturedImage(s string) {
	m.featured_image = &s
}

// FeaturedImage returns the value of the "featured_image" field in the mutation.
func (m *NFTClassMutation) FeaturedImage() (r string, exists bool) {
	v := m.featured_image
	if v == nil {
		return
	}
	return *v, true
}

// OldFeaturedImage returns the old "featured_image" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldFeaturedImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeaturedImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeaturedImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeaturedImage: %w", err)
	}
	return oldValue.FeaturedImage, nil
}

// ResetFeaturedImage resets all changes to the "featured_image" field.
func (m *NFTClassMutation) ResetFeaturedImage() {
	m.featured_image = nil
}

// SetDeployerAddress sets the "deployer_address" field.
func (m *NFTClassMutation) SetDeployerAddress(s string) {
	m.deployer_address = &s
}

// DeployerAddress returns the value of the "deployer_address" field in the mutation.
func (m *NFTClassMutation) DeployerAddress() (r string, exists bool) {
	v := m.deployer_address
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployerAddress returns the old "deployer_address" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldDeployerAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployerAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployerAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployerAddress: %w", err)
	}
	return oldValue.DeployerAddress, nil
}

// ResetDeployerAddress resets all changes to the "deployer_address" field.
func (m *NFTClassMutation) ResetDeployerAddress() {
	m.deployer_address = nil
}

// SetDeployedBlockNumber sets the "deployed_block_number" field.
func (m *NFTClassMutation) SetDeployedBlockNumber(t typeutil.Uint64) {
	m.deployed_block_number = &t
	m.adddeployed_block_number = nil
}

// DeployedBlockNumber returns the value of the "deployed_block_number" field in the mutation.
func (m *NFTClassMutation) DeployedBlockNumber() (r typeutil.Uint64, exists bool) {
	v := m.deployed_block_number
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployedBlockNumber returns the old "deployed_block_number" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldDeployedBlockNumber(ctx context.Context) (v typeutil.Uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployedBlockNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployedBlockNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployedBlockNumber: %w", err)
	}
	return oldValue.DeployedBlockNumber, nil
}

// AddDeployedBlockNumber adds t to the "deployed_block_number" field.
func (m *NFTClassMutation) AddDeployedBlockNumber(t typeutil.Uint64) {
	if m.adddeployed_block_number != nil {
		*m.adddeployed_block_number += t
	} else {
		m.adddeployed_block_number = &t
	}
}

// AddedDeployedBlockNumber returns the value that was added to the "deployed_block_number" field in this mutation.
func (m *NFTClassMutation) AddedDeployedBlockNumber() (r typeutil.Uint64, exists bool) {
	v := m.adddeployed_block_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeployedBlockNumber resets all changes to the "deployed_block_number" field.
func (m *NFTClassMutation) ResetDeployedBlockNumber() {
	m.deployed_block_number = nil
	m.adddeployed_block_number = nil
}

// SetMintedAt sets the "minted_at" field.
func (m *NFTClassMutation) SetMintedAt(t time.Time) {
	m.minted_at = &t
}

// MintedAt returns the value of the "minted_at" field in the mutation.
func (m *NFTClassMutation) MintedAt() (r time.Time, exists bool) {
	v := m.minted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldMintedAt returns the old "minted_at" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldMintedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMintedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMintedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMintedAt: %w", err)
	}
	return oldValue.MintedAt, nil
}

// ResetMintedAt resets all changes to the "minted_at" field.
func (m *NFTClassMutation) ResetMintedAt() {
	m.minted_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NFTClassMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NFTClassMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NFTClassMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddNftIDs adds the "nfts" edge to the NFT entity by ids.
func (m *NFTClassMutation) AddNftIDs(ids ...int) {
	if m.nfts == nil {
		m.nfts = make(map[int]struct{})
	}
	for i := range ids {
		m.nfts[ids[i]] = struct{}{}
	}
}

// ClearNfts clears the "nfts" edge to the NFT entity.
func (m *NFTClassMutation) ClearNfts() {
	m.clearednfts = true
}

// NftsCleared reports if the "nfts" edge to the NFT entity was cleared.
func (m *NFTClassMutation) NftsCleared() bool {
	return m.clearednfts
}

// RemoveNftIDs removes the "nfts" edge to the NFT entity by IDs.
func (m *NFTClassMutation) RemoveNftIDs(ids ...int) {
	if m.removednfts == nil {
		m.removednfts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.nfts, ids[i])
		m.removednfts[ids[i]] = struct{}{}
	}
}

// RemovedNfts returns the removed IDs of the "nfts" edge to the NFT entity.
func (m *NFTClassMutation) RemovedNftsIDs() (ids []int) {
	for id := range m.removednfts {
		ids = append(ids, id)
	}
	return
}

// NftsIDs returns the "nfts" edge IDs in the mutation.
func (m *NFTClassMutation) NftsIDs() (ids []int) {
	for id := range m.nfts {
		ids = append(ids, id)
	}
	return
}

// ResetNfts resets all changes to the "nfts" edge.
func (m *NFTClassMutation) ResetNfts() {
	m.nfts = nil
	m.clearednfts = false
	m.removednfts = nil
}

// SetOwnerID sets the "owner" edge to the Account entity by id.
func (m *NFTClassMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Account entity.
func (m *NFTClassMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Account entity was cleared.
func (m *NFTClassMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NFTClassMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NFTClassMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NFTClassMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the NFTClassMutation builder.
func (m *NFTClassMutation) Where(ps ...predicate.NFTClass) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NFTClassMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NFTClassMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NFTClass, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NFTClassMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NFTClassMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NFTClass).
func (m *NFTClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NFTClassMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.address != nil {
		fields = append(fields, nftclass.FieldAddress)
	}
	if m.name != nil {
		fields = append(fields, nftclass.FieldName)
	}
	if m.symbol != nil {
		fields = append(fields, nftclass.FieldSymbol)
	}
	if m.owner_address != nil {
		fields = append(fields, nftclass.FieldOwnerAddress)
	}
	if m.minter_addresses != nil {
		fields = append(fields, nftclass.FieldMinterAddresses)
	}
	if m.total_supply != nil {
		fields = append(fields, nftclass.FieldTotalSupply)
	}
	if m.max_supply != nil {
		fields = append(fields, nftclass.FieldMaxSupply)
	}
	if m.metadata != nil {
		fields = append(fields, nftclass.FieldMetadata)
	}
	if m.banner_image != nil {
		fields = append(fields, nftclass.FieldBannerImage)
	}
	if m.featured_image != nil {
		fields = append(fields, nftclass.FieldFeaturedImage)
	}
	if m.deployer_address != nil {
		fields = append(fields, nftclass.FieldDeployerAddress)
	}
	if m.deployed_block_number != nil {
		fields = append(fields, nftclass.FieldDeployedBlockNumber)
	}
	if m.minted_at != nil {
		fields = append(fields, nftclass.FieldMintedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, nftclass.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NFTClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nftclass.FieldAddress:
		return m.Address()
	case nftclass.FieldName:
		return m.Name()
	case nftclass.FieldSymbol:
		return m.Symbol()
	case nftclass.FieldOwnerAddress:
		return m.OwnerAddress()
	case nftclass.FieldMinterAddresses:
		return m.MinterAddresses()
	case nftclass.FieldTotalSupply:
		return m.TotalSupply()
	case nftclass.FieldMaxSupply:
		return m.MaxSupply()
	case nftclass.FieldMetadata:
		return m.Metadata()
	case nftclass.FieldBannerImage:
		return m.BannerImage()
	case nftclass.FieldFeaturedImage:
		return m.FeaturedImage()
	case nftclass.FieldDeployerAddress:
		return m.DeployerAddress()
	case nftclass.FieldDeployedBlockNumber:
		return m.DeployedBlockNumber()
	case nftclass.FieldMintedAt:
		return m.MintedAt()
	case nftclass.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NFTClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nftclass.FieldAddress:
		return m.OldAddress(ctx)
	case nftclass.FieldName:
		return m.OldName(ctx)
	case nftclass.FieldSymbol:
		return m.OldSymbol(ctx)
	case nftclass.FieldOwnerAddress:
		return m.OldOwnerAddress(ctx)
	case nftclass.FieldMinterAddresses:
		return m.OldMinterAddresses(ctx)
	case nftclass.FieldTotalSupply:
		return m.OldTotalSupply(ctx)
	case nftclass.FieldMaxSupply:
		return m.OldMaxSupply(ctx)
	case nftclass.FieldMetadata:
		return m.OldMetadata(ctx)
	case nftclass.FieldBannerImage:
		return m.OldBannerImage(ctx)
	case nftclass.FieldFeaturedImage:
		return m.OldFeaturedImage(ctx)
	case nftclass.FieldDeployerAddress:
		return m.OldDeployerAddress(ctx)
	case nftclass.FieldDeployedBlockNumber:
		return m.OldDeployedBlockNumber(ctx)
	case nftclass.FieldMintedAt:
		return m.OldMintedAt(ctx)
	case nftclass.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NFTClass field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NFTClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nftclass.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case nftclass.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case nftclass.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case nftclass.FieldOwnerAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerAddress(v)
		return nil
	case nftclass.FieldMinterAddresses:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinterAddresses(v)
		return nil
	case nftclass.FieldTotalSupply:
		v, ok := value.(*big.Int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSupply(v)
		return nil
	case nftclass.FieldMaxSupply:
		v, ok := value.(typeutil.Uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxSupply(v)
		return nil
	case nftclass.FieldMetadata:
		v, ok := value.(*model.ContractLevelMetadata)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case nftclass.FieldBannerImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerImage(v)
		return nil
	case nftclass.FieldFeaturedImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeaturedImage(v)
		return nil
	case nftclass.FieldDeployerAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployerAddress(v)
		return nil
	case nftclass.FieldDeployedBlockNumber:
		v, ok := value.(typeutil.Uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployedBlockNumber(v)
		return nil
	case nftclass.FieldMintedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMintedAt(v)
		return nil
	case nftclass.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NFTClass field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NFTClassMutation) AddedFields() []string {
	var fields []string
	if m.addmax_supply != nil {
		fields = append(fields, nftclass.FieldMaxSupply)
	}
	if m.adddeployed_block_number != nil {
		fields = append(fields, nftclass.FieldDeployedBlockNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NFTClassMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case nftclass.FieldMaxSupply:
		return m.AddedMaxSupply()
	case nftclass.FieldDeployedBlockNumber:
		return m.AddedDeployedBlockNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NFTClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	case nftclass.FieldMaxSupply:
		v, ok := value.(typeutil.Uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxSupply(v)
		return nil
	case nftclass.FieldDeployedBlockNumber:
		v, ok := value.(typeutil.Uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeployedBlockNumber(v)
		return nil
	}
	return fmt.Errorf("unknown NFTClass numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NFTClassMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(nftclass.FieldOwnerAddress) {
		fields = append(fields, nftclass.FieldOwnerAddress)
	}
	if m.FieldCleared(nftclass.FieldMinterAddresses) {
		fields = append(fields, nftclass.FieldMinterAddresses)
	}
	if m.FieldCleared(nftclass.FieldMetadata) {
		fields = append(fields, nftclass.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NFTClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NFTClassMutation) ClearField(name string) error {
	switch name {
	case nftclass.FieldOwnerAddress:
		m.ClearOwnerAddress()
		return nil
	case nftclass.FieldMinterAddresses:
		m.ClearMinterAddresses()
		return nil
	case nftclass.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown NFTClass nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NFTClassMutation) ResetField(name string) error {
	switch name {
	case nftclass.FieldAddress:
		m.ResetAddress()
		return nil
	case nftclass.FieldName:
		m.ResetName()
		return nil
	case nftclass.FieldSymbol:
		m.ResetSymbol()
		return nil
	case nftclass.FieldOwnerAddress:
		m.ResetOwnerAddress()
		return nil
	case nftclass.FieldMinterAddresses:
		m.ResetMinterAddresses()
		return nil
	case nftclass.FieldTotalSupply:
		m.ResetTotalSupply()
		return nil
	case nftclass.FieldMaxSupply:
		m.ResetMaxSupply()
		return nil
	case nftclass.FieldMetadata:
		m.ResetMetadata()
		return nil
	case nftclass.FieldBannerImage:
		m.ResetBannerImage()
		return nil
	case nftclass.FieldFeaturedImage:
		m.ResetFeaturedImage()
		return nil
	case nftclass.FieldDeployerAddress:
		m.ResetDeployerAddress()
		return nil
	case nftclass.FieldDeployedBlockNumber:
		m.ResetDeployedBlockNumber()
		return nil
	case nftclass.FieldMintedAt:
		m.ResetMintedAt()
		return nil
	case nftclass.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown NFTClass field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NFTClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.nfts != nil {
		edges = append(edges, nftclass.EdgeNfts)
	}
	if m.owner != nil {
		edges = append(edges, nftclass.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NFTClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nftclass.EdgeNfts:
		ids := make([]ent.Value, 0, len(m.nfts))
		for id := range m.nfts {
			ids = append(ids, id)
		}
		return ids
	case nftclass.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NFTClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednfts != nil {
		edges = append(edges, nftclass.EdgeNfts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NFTClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nftclass.EdgeNfts:
		ids := make([]ent.Value, 0, len(m.removednfts))
		for id := range m.removednfts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NFTClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednfts {
		edges = append(edges, nftclass.EdgeNfts)
	}
	if m.clearedowner {
		edges = append(edges, nftclass.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NFTClassMutation) EdgeCleared(name string) bool {
	switch name {
	case nftclass.EdgeNfts:
		return m.clearednfts
	case nftclass.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NFTClassMutation) ClearEdge(name string) error {
	switch name {
	case nftclass.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown NFTClass unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NFTClassMutation) ResetEdge(name string) error {
	switch name {
	case nftclass.EdgeNfts:
		m.ResetNfts()
		return nil
	case nftclass.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown NFTClass edge %s", name)
}

// TransactionMemoMutation represents an operation that mutates the TransactionMemo nodes in the graph.
type TransactionMemoMutation struct {
	config
	op               Op
	typ              string
	id               *int
	transaction_hash *string
	book_nft_id      *string
	from             *string
	to               *string
	token_id         *typeutil.Uint64
	addtoken_id      *typeutil.Uint64
	memo             *string
	block_number     *typeutil.Uint64
	addblock_number  *typeutil.Uint64
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*TransactionMemo, error)
	predicates       []predicate.TransactionMemo
}

var _ ent.Mutation = (*TransactionMemoMutation)(nil)

// transactionmemoOption allows management of the mutation configuration using functional options.
type transactionmemoOption func(*TransactionMemoMutation)

// newTransactionMemoMutation creates new mutation for the TransactionMemo entity.
func newTransactionMemoMutation(c config, op Op, opts ...transactionmemoOption) *TransactionMemoMutation {
	m := &TransactionMemoMutation{
		config:        c,
		op:            op,
		typ:           TypeTransactionMemo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionMemoID sets the ID field of the mutation.
func withTransactionMemoID(id int) transactionmemoOption {
	return func(m *TransactionMemoMutation) {
		var (
			err   error
			once  sync.Once
			value *TransactionMemo
		)
		m.oldValue = func(ctx context.Context) (*TransactionMemo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransactionMemo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransactionMemo sets the old TransactionMemo of the mutation.
func withTransactionMemo(node *TransactionMemo) transactionmemoOption {
	return func(m *TransactionMemoMutation) {
		m.oldValue = func(context.Context) (*TransactionMemo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMemoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMemoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMemoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMemoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransactionMemo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTransactionHash sets the "transaction_hash" field.
func (m *TransactionMemoMutation) SetTransactionHash(s string) {
	m.transaction_hash = &s
}

// TransactionHash returns the value of the "transaction_hash" field in the mutation.
func (m *TransactionMemoMutation) TransactionHash() (r string, exists bool) {
	v := m.transaction_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionHash returns the old "transaction_hash" field's value of the TransactionMemo entity.
// If the TransactionMemo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMemoMutation) OldTransactionHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionHash: %w", err)
	}
	return oldValue.TransactionHash, nil
}

// ResetTransactionHash resets all changes to the "transaction_hash" field.
func (m *TransactionMemoMutation) ResetTransactionHash() {
	m.transaction_hash = nil
}

// SetBookNftID sets the "book_nft_id" field.
func (m *TransactionMemoMutation) SetBookNftID(s string) {
	m.book_nft_id = &s
}

// BookNftID returns the value of the "book_nft_id" field in the mutation.
func (m *TransactionMemoMutation) BookNftID() (r string, exists bool) {
	v := m.book_nft_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBookNftID returns the old "book_nft_id" field's value of the TransactionMemo entity.
// If the TransactionMemo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMemoMutation) OldBookNftID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBookNftID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBookNftID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookNftID: %w", err)
	}
	return oldValue.BookNftID, nil
}

// ResetBookNftID resets all changes to the "book_nft_id" field.
func (m *TransactionMemoMutation) ResetBookNftID() {
	m.book_nft_id = nil
}

// SetFrom sets the "from" field.
func (m *TransactionMemoMutation) SetFrom(s string) {
	m.from = &s
}

// From returns the value of the "from" field in the mutation.
func (m *TransactionMemoMutation) From() (r string, exists bool) {
	v := m.from
	if v == nil {
		return
	}
	return *v, true
}

// OldFrom returns the old "from" field's value of the TransactionMemo entity.
// If the TransactionMemo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMemoMutation) OldFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrom: %w", err)
	}
	return oldValue.From, nil
}

// ResetFrom resets all changes to the "from" field.
func (m *TransactionMemoMutation) ResetFrom() {
	m.from = nil
}

// SetTo sets the "to" field.
func (m *TransactionMemoMutation) SetTo(s string) {
	m.to = &s
}

// To returns the value of the "to" field in the mutation.
func (m *TransactionMemoMutation) To() (r string, exists bool) {
	v := m.to
	if v == nil {
		return
	}
	return *v, true
}

// OldTo returns the old "to" field's value of the TransactionMemo entity.
// If the TransactionMemo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMemoMutation) OldTo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTo: %w", err)
	}
	return oldValue.To, nil
}

// ResetTo resets all changes to the "to" field.
func (m *TransactionMemoMutation) ResetTo() {
	m.to = nil
}

// SetTokenID sets the "token_id" field.
func (m *TransactionMemoMutation) SetTokenID(t typeutil.Uint64) {
	m.token_id = &t
	m.addtoken_id = nil
}

// TokenID returns the value of the "token_id" field in the mutation.
func (m *TransactionMemoMutation) TokenID() (r typeutil.Uint64, exists bool) {
	v := m.token_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenID returns the old "token_id" field's value of the TransactionMemo entity.
// If the TransactionMemo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMemoMutation) OldTokenID(ctx context.Context) (v typeutil.Uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenID: %w", err)
	}
	return oldValue.TokenID, nil
}

// AddTokenID adds t to the "token_id" field.
func (m *TransactionMemoMutation) AddTokenID(t typeutil.Uint64) {
	if m.addtoken_id != nil {
		*m.addtoken_id += t
	} else {
		m.addtoken_id = &t
	}
}

// AddedTokenID returns the value that was added to the "token_id" field in this mutation.
func (m *TransactionMemoMutation) AddedTokenID() (r typeutil.Uint64, exists bool) {
	v := m.addtoken_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTokenID resets all changes to the "token_id" field.
func (m *TransactionMemoMutation) ResetTokenID() {
	m.token_id = nil
	m.addtoken_id = nil
}

// SetMemo sets the "memo" field.
func (m *TransactionMemoMutation) SetMemo(s string) {
	m.memo = &s
}

// Memo returns the value of the "memo" field in the mutation.
func (m *TransactionMemoMutation) Memo() (r string, exists bool) {
	v := m.memo
	if v == nil {
		return
	}
	return *v, true
}

// OldMemo returns the old "memo" field's value of the TransactionMemo entity.
// If the TransactionMemo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMemoMutation) OldMemo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemo: %w", err)
	}
	return oldValue.Memo, nil
}

// ResetMemo resets all changes to the "memo" field.
func (m *TransactionMemoMutation) ResetMemo() {
	m.memo = nil
}

// SetBlockNumber sets the "block_number" field.
func (m *TransactionMemoMutation) SetBlockNumber(t typeutil.Uint64) {
	m.block_number = &t
	m.addblock_number = nil
}

// BlockNumber returns the value of the "block_number" field in the mutation.
func (m *TransactionMemoMutation) BlockNumber() (r typeutil.Uint64, exists bool) {
	v := m.block_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockNumber returns the old "block_number" field's value of the TransactionMemo entity.
// If the TransactionMemo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMemoMutation) OldBlockNumber(ctx context.Context) (v typeutil.Uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockNumber: %w", err)
	}
	return oldValue.BlockNumber, nil
}

// AddBlockNumber adds t to the "block_number" field.
func (m *TransactionMemoMutation) AddBlockNumber(t typeutil.Uint64) {
	if m.addblock_number != nil {
		*m.addblock_number += t
	} else {
		m.addblock_number = &t
	}
}

// AddedBlockNumber returns the value that was added to the "block_number" field in this mutation.
func (m *TransactionMemoMutation) AddedBlockNumber() (r typeutil.Uint64, exists bool) {
	v := m.addblock_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockNumber resets all changes to the "block_number" field.
func (m *TransactionMemoMutation) ResetBlockNumber() {
	m.block_number = nil
	m.addblock_number = nil
}

// Where appends a list predicates to the TransactionMemoMutation builder.
func (m *TransactionMemoMutation) Where(ps ...predicate.TransactionMemo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionMemoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionMemoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TransactionMemo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionMemoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionMemoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TransactionMemo).
func (m *TransactionMemoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMemoMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.transaction_hash != nil {
		fields = append(fields, transactionmemo.FieldTransactionHash)
	}
	if m.book_nft_id != nil {
		fields = append(fields, transactionmemo.FieldBookNftID)
	}
	if m.from != nil {
		fields = append(fields, transactionmemo.FieldFrom)
	}
	if m.to != nil {
		fields = append(fields, transactionmemo.FieldTo)
	}
	if m.token_id != nil {
		fields = append(fields, transactionmemo.FieldTokenID)
	}
	if m.memo != nil {
		fields = append(fields, transactionmemo.FieldMemo)
	}
	if m.block_number != nil {
		fields = append(fields, transactionmemo.FieldBlockNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMemoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transactionmemo.FieldTransactionHash:
		return m.TransactionHash()
	case transactionmemo.FieldBookNftID:
		return m.BookNftID()
	case transactionmemo.FieldFrom:
		return m.From()
	case transactionmemo.FieldTo:
		return m.To()
	case transactionmemo.FieldTokenID:
		return m.TokenID()
	case transactionmemo.FieldMemo:
		return m.Memo()
	case transactionmemo.FieldBlockNumber:
		return m.BlockNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMemoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transactionmemo.FieldTransactionHash:
		return m.OldTransactionHash(ctx)
	case transactionmemo.FieldBookNftID:
		return m.OldBookNftID(ctx)
	case transactionmemo.FieldFrom:
		return m.OldFrom(ctx)
	case transactionmemo.FieldTo:
		return m.OldTo(ctx)
	case transactionmemo.FieldTokenID:
		return m.OldTokenID(ctx)
	case transactionmemo.FieldMemo:
		return m.OldMemo(ctx)
	case transactionmemo.FieldBlockNumber:
		return m.OldBlockNumber(ctx)
	}
	return nil, fmt.Errorf("unknown TransactionMemo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMemoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transactionmemo.FieldTransactionHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionHash(v)
		return nil
	case transactionmemo.FieldBookNftID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookNftID(v)
		return nil
	case transactionmemo.FieldFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrom(v)
		return nil
	case transactionmemo.FieldTo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTo(v)
		return nil
	case transactionmemo.FieldTokenID:
		v, ok := value.(typeutil.Uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenID(v)
		return nil
	case transactionmemo.FieldMemo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemo(v)
		return nil
	case transactionmemo.FieldBlockNumber:
		v, ok := value.(typeutil.Uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockNumber(v)
		return nil
	}
	return fmt.Errorf("unknown TransactionMemo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMemoMutation) AddedFields() []string {
	var fields []string
	if m.addtoken_id != nil {
		fields = append(fields, transactionmemo.FieldTokenID)
	}
	if m.addblock_number != nil {
		fields = append(fields, transactionmemo.FieldBlockNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMemoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transactionmemo.FieldTokenID:
		return m.AddedTokenID()
	case transactionmemo.FieldBlockNumber:
		return m.AddedBlockNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMemoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transactionmemo.FieldTokenID:
		v, ok := value.(typeutil.Uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokenID(v)
		return nil
	case transactionmemo.FieldBlockNumber:
		v, ok := value.(typeutil.Uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockNumber(v)
		return nil
	}
	return fmt.Errorf("unknown TransactionMemo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMemoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMemoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMemoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TransactionMemo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMemoMutation) ResetField(name string) error {
	switch name {
	case transactionmemo.FieldTransactionHash:
		m.ResetTransactionHash()
		return nil
	case transactionmemo.FieldBookNftID:
		m.ResetBookNftID()
		return nil
	case transactionmemo.FieldFrom:
		m.ResetFrom()
		return nil
	case transactionmemo.FieldTo:
		m.ResetTo()
		return nil
	case transactionmemo.FieldTokenID:
		m.ResetTokenID()
		return nil
	case transactionmemo.FieldMemo:
		m.ResetMemo()
		return nil
	case transactionmemo.FieldBlockNumber:
		m.ResetBlockNumber()
		return nil
	}
	return fmt.Errorf("unknown TransactionMemo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMemoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMemoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMemoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMemoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMemoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMemoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMemoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TransactionMemo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMemoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TransactionMemo edge %s", name)
}
