// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"likenft-indexer/ent/account"
	"likenft-indexer/ent/nft"
	"likenft-indexer/ent/nftclass"
	"likenft-indexer/ent/predicate"
	"likenft-indexer/ent/schema/typeutil"
	"likenft-indexer/internal/evm/model"
	"math/big"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/dialect/sql/sqljson"
	"entgo.io/ent/schema/field"
)

// NFTClassUpdate is the builder for updating NFTClass entities.
type NFTClassUpdate struct {
	config
	hooks    []Hook
	mutation *NFTClassMutation
}

// Where appends a list predicates to the NFTClassUpdate builder.
func (ncu *NFTClassUpdate) Where(ps ...predicate.NFTClass) *NFTClassUpdate {
	ncu.mutation.Where(ps...)
	return ncu
}

// SetAcquireBookNftEventsWeight sets the "acquire_book_nft_events_weight" field.
func (ncu *NFTClassUpdate) SetAcquireBookNftEventsWeight(f float64) *NFTClassUpdate {
	ncu.mutation.ResetAcquireBookNftEventsWeight()
	ncu.mutation.SetAcquireBookNftEventsWeight(f)
	return ncu
}

// SetNillableAcquireBookNftEventsWeight sets the "acquire_book_nft_events_weight" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableAcquireBookNftEventsWeight(f *float64) *NFTClassUpdate {
	if f != nil {
		ncu.SetAcquireBookNftEventsWeight(*f)
	}
	return ncu
}

// AddAcquireBookNftEventsWeight adds f to the "acquire_book_nft_events_weight" field.
func (ncu *NFTClassUpdate) AddAcquireBookNftEventsWeight(f float64) *NFTClassUpdate {
	ncu.mutation.AddAcquireBookNftEventsWeight(f)
	return ncu
}

// SetAcquireBookNftEventsLastProcessedTime sets the "acquire_book_nft_events_last_processed_time" field.
func (ncu *NFTClassUpdate) SetAcquireBookNftEventsLastProcessedTime(t time.Time) *NFTClassUpdate {
	ncu.mutation.SetAcquireBookNftEventsLastProcessedTime(t)
	return ncu
}

// SetNillableAcquireBookNftEventsLastProcessedTime sets the "acquire_book_nft_events_last_processed_time" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableAcquireBookNftEventsLastProcessedTime(t *time.Time) *NFTClassUpdate {
	if t != nil {
		ncu.SetAcquireBookNftEventsLastProcessedTime(*t)
	}
	return ncu
}

// ClearAcquireBookNftEventsLastProcessedTime clears the value of the "acquire_book_nft_events_last_processed_time" field.
func (ncu *NFTClassUpdate) ClearAcquireBookNftEventsLastProcessedTime() *NFTClassUpdate {
	ncu.mutation.ClearAcquireBookNftEventsLastProcessedTime()
	return ncu
}

// SetAcquireBookNftEventsScore sets the "acquire_book_nft_events_score" field.
func (ncu *NFTClassUpdate) SetAcquireBookNftEventsScore(f float64) *NFTClassUpdate {
	ncu.mutation.ResetAcquireBookNftEventsScore()
	ncu.mutation.SetAcquireBookNftEventsScore(f)
	return ncu
}

// SetNillableAcquireBookNftEventsScore sets the "acquire_book_nft_events_score" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableAcquireBookNftEventsScore(f *float64) *NFTClassUpdate {
	if f != nil {
		ncu.SetAcquireBookNftEventsScore(*f)
	}
	return ncu
}

// AddAcquireBookNftEventsScore adds f to the "acquire_book_nft_events_score" field.
func (ncu *NFTClassUpdate) AddAcquireBookNftEventsScore(f float64) *NFTClassUpdate {
	ncu.mutation.AddAcquireBookNftEventsScore(f)
	return ncu
}

// ClearAcquireBookNftEventsScore clears the value of the "acquire_book_nft_events_score" field.
func (ncu *NFTClassUpdate) ClearAcquireBookNftEventsScore() *NFTClassUpdate {
	ncu.mutation.ClearAcquireBookNftEventsScore()
	return ncu
}

// SetAcquireBookNftEventsStatus sets the "acquire_book_nft_events_status" field.
func (ncu *NFTClassUpdate) SetAcquireBookNftEventsStatus(nbnes nftclass.AcquireBookNftEventsStatus) *NFTClassUpdate {
	ncu.mutation.SetAcquireBookNftEventsStatus(nbnes)
	return ncu
}

// SetNillableAcquireBookNftEventsStatus sets the "acquire_book_nft_events_status" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableAcquireBookNftEventsStatus(nbnes *nftclass.AcquireBookNftEventsStatus) *NFTClassUpdate {
	if nbnes != nil {
		ncu.SetAcquireBookNftEventsStatus(*nbnes)
	}
	return ncu
}

// ClearAcquireBookNftEventsStatus clears the value of the "acquire_book_nft_events_status" field.
func (ncu *NFTClassUpdate) ClearAcquireBookNftEventsStatus() *NFTClassUpdate {
	ncu.mutation.ClearAcquireBookNftEventsStatus()
	return ncu
}

// SetAcquireBookNftEventsFailedReason sets the "acquire_book_nft_events_failed_reason" field.
func (ncu *NFTClassUpdate) SetAcquireBookNftEventsFailedReason(s string) *NFTClassUpdate {
	ncu.mutation.SetAcquireBookNftEventsFailedReason(s)
	return ncu
}

// SetNillableAcquireBookNftEventsFailedReason sets the "acquire_book_nft_events_failed_reason" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableAcquireBookNftEventsFailedReason(s *string) *NFTClassUpdate {
	if s != nil {
		ncu.SetAcquireBookNftEventsFailedReason(*s)
	}
	return ncu
}

// ClearAcquireBookNftEventsFailedReason clears the value of the "acquire_book_nft_events_failed_reason" field.
func (ncu *NFTClassUpdate) ClearAcquireBookNftEventsFailedReason() *NFTClassUpdate {
	ncu.mutation.ClearAcquireBookNftEventsFailedReason()
	return ncu
}

// SetAcquireBookNftEventsFailedCount sets the "acquire_book_nft_events_failed_count" field.
func (ncu *NFTClassUpdate) SetAcquireBookNftEventsFailedCount(i int) *NFTClassUpdate {
	ncu.mutation.ResetAcquireBookNftEventsFailedCount()
	ncu.mutation.SetAcquireBookNftEventsFailedCount(i)
	return ncu
}

// SetNillableAcquireBookNftEventsFailedCount sets the "acquire_book_nft_events_failed_count" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableAcquireBookNftEventsFailedCount(i *int) *NFTClassUpdate {
	if i != nil {
		ncu.SetAcquireBookNftEventsFailedCount(*i)
	}
	return ncu
}

// AddAcquireBookNftEventsFailedCount adds i to the "acquire_book_nft_events_failed_count" field.
func (ncu *NFTClassUpdate) AddAcquireBookNftEventsFailedCount(i int) *NFTClassUpdate {
	ncu.mutation.AddAcquireBookNftEventsFailedCount(i)
	return ncu
}

// SetAddress sets the "address" field.
func (ncu *NFTClassUpdate) SetAddress(s string) *NFTClassUpdate {
	ncu.mutation.SetAddress(s)
	return ncu
}

// SetNillableAddress sets the "address" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableAddress(s *string) *NFTClassUpdate {
	if s != nil {
		ncu.SetAddress(*s)
	}
	return ncu
}

// SetName sets the "name" field.
func (ncu *NFTClassUpdate) SetName(s string) *NFTClassUpdate {
	ncu.mutation.SetName(s)
	return ncu
}

// SetNillableName sets the "name" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableName(s *string) *NFTClassUpdate {
	if s != nil {
		ncu.SetName(*s)
	}
	return ncu
}

// SetSymbol sets the "symbol" field.
func (ncu *NFTClassUpdate) SetSymbol(s string) *NFTClassUpdate {
	ncu.mutation.SetSymbol(s)
	return ncu
}

// SetNillableSymbol sets the "symbol" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableSymbol(s *string) *NFTClassUpdate {
	if s != nil {
		ncu.SetSymbol(*s)
	}
	return ncu
}

// SetOwnerAddress sets the "owner_address" field.
func (ncu *NFTClassUpdate) SetOwnerAddress(s string) *NFTClassUpdate {
	ncu.mutation.SetOwnerAddress(s)
	return ncu
}

// SetNillableOwnerAddress sets the "owner_address" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableOwnerAddress(s *string) *NFTClassUpdate {
	if s != nil {
		ncu.SetOwnerAddress(*s)
	}
	return ncu
}

// ClearOwnerAddress clears the value of the "owner_address" field.
func (ncu *NFTClassUpdate) ClearOwnerAddress() *NFTClassUpdate {
	ncu.mutation.ClearOwnerAddress()
	return ncu
}

// SetMinterAddresses sets the "minter_addresses" field.
func (ncu *NFTClassUpdate) SetMinterAddresses(s []string) *NFTClassUpdate {
	ncu.mutation.SetMinterAddresses(s)
	return ncu
}

// AppendMinterAddresses appends s to the "minter_addresses" field.
func (ncu *NFTClassUpdate) AppendMinterAddresses(s []string) *NFTClassUpdate {
	ncu.mutation.AppendMinterAddresses(s)
	return ncu
}

// ClearMinterAddresses clears the value of the "minter_addresses" field.
func (ncu *NFTClassUpdate) ClearMinterAddresses() *NFTClassUpdate {
	ncu.mutation.ClearMinterAddresses()
	return ncu
}

// SetTotalSupply sets the "total_supply" field.
func (ncu *NFTClassUpdate) SetTotalSupply(b *big.Int) *NFTClassUpdate {
	ncu.mutation.SetTotalSupply(b)
	return ncu
}

// SetMaxSupply sets the "max_supply" field.
func (ncu *NFTClassUpdate) SetMaxSupply(t typeutil.Uint64) *NFTClassUpdate {
	ncu.mutation.ResetMaxSupply()
	ncu.mutation.SetMaxSupply(t)
	return ncu
}

// SetNillableMaxSupply sets the "max_supply" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableMaxSupply(t *typeutil.Uint64) *NFTClassUpdate {
	if t != nil {
		ncu.SetMaxSupply(*t)
	}
	return ncu
}

// AddMaxSupply adds t to the "max_supply" field.
func (ncu *NFTClassUpdate) AddMaxSupply(t typeutil.Uint64) *NFTClassUpdate {
	ncu.mutation.AddMaxSupply(t)
	return ncu
}

// SetMetadata sets the "metadata" field.
func (ncu *NFTClassUpdate) SetMetadata(mlm *model.ContractLevelMetadata) *NFTClassUpdate {
	ncu.mutation.SetMetadata(mlm)
	return ncu
}

// ClearMetadata clears the value of the "metadata" field.
func (ncu *NFTClassUpdate) ClearMetadata() *NFTClassUpdate {
	ncu.mutation.ClearMetadata()
	return ncu
}

// SetBannerImage sets the "banner_image" field.
func (ncu *NFTClassUpdate) SetBannerImage(s string) *NFTClassUpdate {
	ncu.mutation.SetBannerImage(s)
	return ncu
}

// SetNillableBannerImage sets the "banner_image" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableBannerImage(s *string) *NFTClassUpdate {
	if s != nil {
		ncu.SetBannerImage(*s)
	}
	return ncu
}

// SetFeaturedImage sets the "featured_image" field.
func (ncu *NFTClassUpdate) SetFeaturedImage(s string) *NFTClassUpdate {
	ncu.mutation.SetFeaturedImage(s)
	return ncu
}

// SetNillableFeaturedImage sets the "featured_image" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableFeaturedImage(s *string) *NFTClassUpdate {
	if s != nil {
		ncu.SetFeaturedImage(*s)
	}
	return ncu
}

// SetDeployerAddress sets the "deployer_address" field.
func (ncu *NFTClassUpdate) SetDeployerAddress(s string) *NFTClassUpdate {
	ncu.mutation.SetDeployerAddress(s)
	return ncu
}

// SetNillableDeployerAddress sets the "deployer_address" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableDeployerAddress(s *string) *NFTClassUpdate {
	if s != nil {
		ncu.SetDeployerAddress(*s)
	}
	return ncu
}

// SetDeployedBlockNumber sets the "deployed_block_number" field.
func (ncu *NFTClassUpdate) SetDeployedBlockNumber(t typeutil.Uint64) *NFTClassUpdate {
	ncu.mutation.ResetDeployedBlockNumber()
	ncu.mutation.SetDeployedBlockNumber(t)
	return ncu
}

// SetNillableDeployedBlockNumber sets the "deployed_block_number" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableDeployedBlockNumber(t *typeutil.Uint64) *NFTClassUpdate {
	if t != nil {
		ncu.SetDeployedBlockNumber(*t)
	}
	return ncu
}

// AddDeployedBlockNumber adds t to the "deployed_block_number" field.
func (ncu *NFTClassUpdate) AddDeployedBlockNumber(t typeutil.Uint64) *NFTClassUpdate {
	ncu.mutation.AddDeployedBlockNumber(t)
	return ncu
}

// SetLatestEventBlockNumber sets the "latest_event_block_number" field.
func (ncu *NFTClassUpdate) SetLatestEventBlockNumber(t typeutil.Uint64) *NFTClassUpdate {
	ncu.mutation.ResetLatestEventBlockNumber()
	ncu.mutation.SetLatestEventBlockNumber(t)
	return ncu
}

// SetNillableLatestEventBlockNumber sets the "latest_event_block_number" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableLatestEventBlockNumber(t *typeutil.Uint64) *NFTClassUpdate {
	if t != nil {
		ncu.SetLatestEventBlockNumber(*t)
	}
	return ncu
}

// AddLatestEventBlockNumber adds t to the "latest_event_block_number" field.
func (ncu *NFTClassUpdate) AddLatestEventBlockNumber(t typeutil.Uint64) *NFTClassUpdate {
	ncu.mutation.AddLatestEventBlockNumber(t)
	return ncu
}

// SetDisabledForIndexing sets the "disabled_for_indexing" field.
func (ncu *NFTClassUpdate) SetDisabledForIndexing(b bool) *NFTClassUpdate {
	ncu.mutation.SetDisabledForIndexing(b)
	return ncu
}

// SetNillableDisabledForIndexing sets the "disabled_for_indexing" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableDisabledForIndexing(b *bool) *NFTClassUpdate {
	if b != nil {
		ncu.SetDisabledForIndexing(*b)
	}
	return ncu
}

// SetDisabledForIndexingReason sets the "disabled_for_indexing_reason" field.
func (ncu *NFTClassUpdate) SetDisabledForIndexingReason(s string) *NFTClassUpdate {
	ncu.mutation.SetDisabledForIndexingReason(s)
	return ncu
}

// SetNillableDisabledForIndexingReason sets the "disabled_for_indexing_reason" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableDisabledForIndexingReason(s *string) *NFTClassUpdate {
	if s != nil {
		ncu.SetDisabledForIndexingReason(*s)
	}
	return ncu
}

// ClearDisabledForIndexingReason clears the value of the "disabled_for_indexing_reason" field.
func (ncu *NFTClassUpdate) ClearDisabledForIndexingReason() *NFTClassUpdate {
	ncu.mutation.ClearDisabledForIndexingReason()
	return ncu
}

// SetMintedAt sets the "minted_at" field.
func (ncu *NFTClassUpdate) SetMintedAt(t time.Time) *NFTClassUpdate {
	ncu.mutation.SetMintedAt(t)
	return ncu
}

// SetNillableMintedAt sets the "minted_at" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableMintedAt(t *time.Time) *NFTClassUpdate {
	if t != nil {
		ncu.SetMintedAt(*t)
	}
	return ncu
}

// SetUpdatedAt sets the "updated_at" field.
func (ncu *NFTClassUpdate) SetUpdatedAt(t time.Time) *NFTClassUpdate {
	ncu.mutation.SetUpdatedAt(t)
	return ncu
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableUpdatedAt(t *time.Time) *NFTClassUpdate {
	if t != nil {
		ncu.SetUpdatedAt(*t)
	}
	return ncu
}

// AddNftIDs adds the "nfts" edge to the NFT entity by IDs.
func (ncu *NFTClassUpdate) AddNftIDs(ids ...int) *NFTClassUpdate {
	ncu.mutation.AddNftIDs(ids...)
	return ncu
}

// AddNfts adds the "nfts" edges to the NFT entity.
func (ncu *NFTClassUpdate) AddNfts(n ...*NFT) *NFTClassUpdate {
	ids := make([]int, len(n))
	for i := range n {
		ids[i] = n[i].ID
	}
	return ncu.AddNftIDs(ids...)
}

// SetOwnerID sets the "owner" edge to the Account entity by ID.
func (ncu *NFTClassUpdate) SetOwnerID(id int) *NFTClassUpdate {
	ncu.mutation.SetOwnerID(id)
	return ncu
}

// SetNillableOwnerID sets the "owner" edge to the Account entity by ID if the given value is not nil.
func (ncu *NFTClassUpdate) SetNillableOwnerID(id *int) *NFTClassUpdate {
	if id != nil {
		ncu = ncu.SetOwnerID(*id)
	}
	return ncu
}

// SetOwner sets the "owner" edge to the Account entity.
func (ncu *NFTClassUpdate) SetOwner(a *Account) *NFTClassUpdate {
	return ncu.SetOwnerID(a.ID)
}

// Mutation returns the NFTClassMutation object of the builder.
func (ncu *NFTClassUpdate) Mutation() *NFTClassMutation {
	return ncu.mutation
}

// ClearNfts clears all "nfts" edges to the NFT entity.
func (ncu *NFTClassUpdate) ClearNfts() *NFTClassUpdate {
	ncu.mutation.ClearNfts()
	return ncu
}

// RemoveNftIDs removes the "nfts" edge to NFT entities by IDs.
func (ncu *NFTClassUpdate) RemoveNftIDs(ids ...int) *NFTClassUpdate {
	ncu.mutation.RemoveNftIDs(ids...)
	return ncu
}

// RemoveNfts removes "nfts" edges to NFT entities.
func (ncu *NFTClassUpdate) RemoveNfts(n ...*NFT) *NFTClassUpdate {
	ids := make([]int, len(n))
	for i := range n {
		ids[i] = n[i].ID
	}
	return ncu.RemoveNftIDs(ids...)
}

// ClearOwner clears the "owner" edge to the Account entity.
func (ncu *NFTClassUpdate) ClearOwner() *NFTClassUpdate {
	ncu.mutation.ClearOwner()
	return ncu
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (ncu *NFTClassUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, ncu.sqlSave, ncu.mutation, ncu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (ncu *NFTClassUpdate) SaveX(ctx context.Context) int {
	affected, err := ncu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (ncu *NFTClassUpdate) Exec(ctx context.Context) error {
	_, err := ncu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ncu *NFTClassUpdate) ExecX(ctx context.Context) {
	if err := ncu.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (ncu *NFTClassUpdate) check() error {
	if v, ok := ncu.mutation.AcquireBookNftEventsWeight(); ok {
		if err := nftclass.AcquireBookNftEventsWeightValidator(v); err != nil {
			return &ValidationError{Name: "acquire_book_nft_events_weight", err: fmt.Errorf(`ent: validator failed for field "NFTClass.acquire_book_nft_events_weight": %w`, err)}
		}
	}
	if v, ok := ncu.mutation.AcquireBookNftEventsStatus(); ok {
		if err := nftclass.AcquireBookNftEventsStatusValidator(v); err != nil {
			return &ValidationError{Name: "acquire_book_nft_events_status", err: fmt.Errorf(`ent: validator failed for field "NFTClass.acquire_book_nft_events_status": %w`, err)}
		}
	}
	if v, ok := ncu.mutation.Name(); ok {
		if err := nftclass.NameValidator(v); err != nil {
			return &ValidationError{Name: "name", err: fmt.Errorf(`ent: validator failed for field "NFTClass.name": %w`, err)}
		}
	}
	if v, ok := ncu.mutation.Symbol(); ok {
		if err := nftclass.SymbolValidator(v); err != nil {
			return &ValidationError{Name: "symbol", err: fmt.Errorf(`ent: validator failed for field "NFTClass.symbol": %w`, err)}
		}
	}
	if v, ok := ncu.mutation.DeployerAddress(); ok {
		if err := nftclass.DeployerAddressValidator(v); err != nil {
			return &ValidationError{Name: "deployer_address", err: fmt.Errorf(`ent: validator failed for field "NFTClass.deployer_address": %w`, err)}
		}
	}
	return nil
}

func (ncu *NFTClassUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := ncu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(nftclass.Table, nftclass.Columns, sqlgraph.NewFieldSpec(nftclass.FieldID, field.TypeInt))
	if ps := ncu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := ncu.mutation.AcquireBookNftEventsWeight(); ok {
		_spec.SetField(nftclass.FieldAcquireBookNftEventsWeight, field.TypeFloat64, value)
	}
	if value, ok := ncu.mutation.AddedAcquireBookNftEventsWeight(); ok {
		_spec.AddField(nftclass.FieldAcquireBookNftEventsWeight, field.TypeFloat64, value)
	}
	if value, ok := ncu.mutation.AcquireBookNftEventsLastProcessedTime(); ok {
		_spec.SetField(nftclass.FieldAcquireBookNftEventsLastProcessedTime, field.TypeTime, value)
	}
	if ncu.mutation.AcquireBookNftEventsLastProcessedTimeCleared() {
		_spec.ClearField(nftclass.FieldAcquireBookNftEventsLastProcessedTime, field.TypeTime)
	}
	if value, ok := ncu.mutation.AcquireBookNftEventsScore(); ok {
		_spec.SetField(nftclass.FieldAcquireBookNftEventsScore, field.TypeFloat64, value)
	}
	if value, ok := ncu.mutation.AddedAcquireBookNftEventsScore(); ok {
		_spec.AddField(nftclass.FieldAcquireBookNftEventsScore, field.TypeFloat64, value)
	}
	if ncu.mutation.AcquireBookNftEventsScoreCleared() {
		_spec.ClearField(nftclass.FieldAcquireBookNftEventsScore, field.TypeFloat64)
	}
	if value, ok := ncu.mutation.AcquireBookNftEventsStatus(); ok {
		_spec.SetField(nftclass.FieldAcquireBookNftEventsStatus, field.TypeEnum, value)
	}
	if ncu.mutation.AcquireBookNftEventsStatusCleared() {
		_spec.ClearField(nftclass.FieldAcquireBookNftEventsStatus, field.TypeEnum)
	}
	if value, ok := ncu.mutation.AcquireBookNftEventsFailedReason(); ok {
		_spec.SetField(nftclass.FieldAcquireBookNftEventsFailedReason, field.TypeString, value)
	}
	if ncu.mutation.AcquireBookNftEventsFailedReasonCleared() {
		_spec.ClearField(nftclass.FieldAcquireBookNftEventsFailedReason, field.TypeString)
	}
	if value, ok := ncu.mutation.AcquireBookNftEventsFailedCount(); ok {
		_spec.SetField(nftclass.FieldAcquireBookNftEventsFailedCount, field.TypeInt, value)
	}
	if value, ok := ncu.mutation.AddedAcquireBookNftEventsFailedCount(); ok {
		_spec.AddField(nftclass.FieldAcquireBookNftEventsFailedCount, field.TypeInt, value)
	}
	if value, ok := ncu.mutation.Address(); ok {
		_spec.SetField(nftclass.FieldAddress, field.TypeString, value)
	}
	if value, ok := ncu.mutation.Name(); ok {
		_spec.SetField(nftclass.FieldName, field.TypeString, value)
	}
	if value, ok := ncu.mutation.Symbol(); ok {
		_spec.SetField(nftclass.FieldSymbol, field.TypeString, value)
	}
	if value, ok := ncu.mutation.OwnerAddress(); ok {
		_spec.SetField(nftclass.FieldOwnerAddress, field.TypeString, value)
	}
	if ncu.mutation.OwnerAddressCleared() {
		_spec.ClearField(nftclass.FieldOwnerAddress, field.TypeString)
	}
	if value, ok := ncu.mutation.MinterAddresses(); ok {
		_spec.SetField(nftclass.FieldMinterAddresses, field.TypeJSON, value)
	}
	if value, ok := ncu.mutation.AppendedMinterAddresses(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, nftclass.FieldMinterAddresses, value)
		})
	}
	if ncu.mutation.MinterAddressesCleared() {
		_spec.ClearField(nftclass.FieldMinterAddresses, field.TypeJSON)
	}
	if value, ok := ncu.mutation.TotalSupply(); ok {
		vv, err := nftclass.ValueScanner.TotalSupply.Value(value)
		if err != nil {
			return 0, err
		}
		_spec.SetField(nftclass.FieldTotalSupply, field.TypeUint64, vv)
	}
	if value, ok := ncu.mutation.MaxSupply(); ok {
		vv, err := nftclass.ValueScanner.MaxSupply.Value(value)
		if err != nil {
			return 0, err
		}
		_spec.SetField(nftclass.FieldMaxSupply, field.TypeUint64, vv)
	}
	if value, ok := ncu.mutation.AddedMaxSupply(); ok {
		vv, err := nftclass.ValueScanner.MaxSupply.Value(value)
		if err != nil {
			return 0, err
		}
		_spec.AddField(nftclass.FieldMaxSupply, field.TypeUint64, vv)
	}
	if value, ok := ncu.mutation.Metadata(); ok {
		_spec.SetField(nftclass.FieldMetadata, field.TypeJSON, value)
	}
	if ncu.mutation.MetadataCleared() {
		_spec.ClearField(nftclass.FieldMetadata, field.TypeJSON)
	}
	if value, ok := ncu.mutation.BannerImage(); ok {
		_spec.SetField(nftclass.FieldBannerImage, field.TypeString, value)
	}
	if value, ok := ncu.mutation.FeaturedImage(); ok {
		_spec.SetField(nftclass.FieldFeaturedImage, field.TypeString, value)
	}
	if value, ok := ncu.mutation.DeployerAddress(); ok {
		_spec.SetField(nftclass.FieldDeployerAddress, field.TypeString, value)
	}
	if value, ok := ncu.mutation.DeployedBlockNumber(); ok {
		vv, err := nftclass.ValueScanner.DeployedBlockNumber.Value(value)
		if err != nil {
			return 0, err
		}
		_spec.SetField(nftclass.FieldDeployedBlockNumber, field.TypeUint64, vv)
	}
	if value, ok := ncu.mutation.AddedDeployedBlockNumber(); ok {
		vv, err := nftclass.ValueScanner.DeployedBlockNumber.Value(value)
		if err != nil {
			return 0, err
		}
		_spec.AddField(nftclass.FieldDeployedBlockNumber, field.TypeUint64, vv)
	}
	if value, ok := ncu.mutation.LatestEventBlockNumber(); ok {
		vv, err := nftclass.ValueScanner.LatestEventBlockNumber.Value(value)
		if err != nil {
			return 0, err
		}
		_spec.SetField(nftclass.FieldLatestEventBlockNumber, field.TypeUint64, vv)
	}
	if value, ok := ncu.mutation.AddedLatestEventBlockNumber(); ok {
		vv, err := nftclass.ValueScanner.LatestEventBlockNumber.Value(value)
		if err != nil {
			return 0, err
		}
		_spec.AddField(nftclass.FieldLatestEventBlockNumber, field.TypeUint64, vv)
	}
	if value, ok := ncu.mutation.DisabledForIndexing(); ok {
		_spec.SetField(nftclass.FieldDisabledForIndexing, field.TypeBool, value)
	}
	if value, ok := ncu.mutation.DisabledForIndexingReason(); ok {
		_spec.SetField(nftclass.FieldDisabledForIndexingReason, field.TypeString, value)
	}
	if ncu.mutation.DisabledForIndexingReasonCleared() {
		_spec.ClearField(nftclass.FieldDisabledForIndexingReason, field.TypeString)
	}
	if value, ok := ncu.mutation.MintedAt(); ok {
		_spec.SetField(nftclass.FieldMintedAt, field.TypeTime, value)
	}
	if value, ok := ncu.mutation.UpdatedAt(); ok {
		_spec.SetField(nftclass.FieldUpdatedAt, field.TypeTime, value)
	}
	if ncu.mutation.NftsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   nftclass.NftsTable,
			Columns: []string{nftclass.NftsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(nft.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ncu.mutation.RemovedNftsIDs(); len(nodes) > 0 && !ncu.mutation.NftsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   nftclass.NftsTable,
			Columns: []string{nftclass.NftsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(nft.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ncu.mutation.NftsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   nftclass.NftsTable,
			Columns: []string{nftclass.NftsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(nft.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ncu.mutation.OwnerCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   nftclass.OwnerTable,
			Columns: []string{nftclass.OwnerColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(account.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ncu.mutation.OwnerIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   nftclass.OwnerTable,
			Columns: []string{nftclass.OwnerColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(account.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, ncu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{nftclass.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	ncu.mutation.done = true
	return n, nil
}

// NFTClassUpdateOne is the builder for updating a single NFTClass entity.
type NFTClassUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *NFTClassMutation
}

// SetAcquireBookNftEventsWeight sets the "acquire_book_nft_events_weight" field.
func (ncuo *NFTClassUpdateOne) SetAcquireBookNftEventsWeight(f float64) *NFTClassUpdateOne {
	ncuo.mutation.ResetAcquireBookNftEventsWeight()
	ncuo.mutation.SetAcquireBookNftEventsWeight(f)
	return ncuo
}

// SetNillableAcquireBookNftEventsWeight sets the "acquire_book_nft_events_weight" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableAcquireBookNftEventsWeight(f *float64) *NFTClassUpdateOne {
	if f != nil {
		ncuo.SetAcquireBookNftEventsWeight(*f)
	}
	return ncuo
}

// AddAcquireBookNftEventsWeight adds f to the "acquire_book_nft_events_weight" field.
func (ncuo *NFTClassUpdateOne) AddAcquireBookNftEventsWeight(f float64) *NFTClassUpdateOne {
	ncuo.mutation.AddAcquireBookNftEventsWeight(f)
	return ncuo
}

// SetAcquireBookNftEventsLastProcessedTime sets the "acquire_book_nft_events_last_processed_time" field.
func (ncuo *NFTClassUpdateOne) SetAcquireBookNftEventsLastProcessedTime(t time.Time) *NFTClassUpdateOne {
	ncuo.mutation.SetAcquireBookNftEventsLastProcessedTime(t)
	return ncuo
}

// SetNillableAcquireBookNftEventsLastProcessedTime sets the "acquire_book_nft_events_last_processed_time" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableAcquireBookNftEventsLastProcessedTime(t *time.Time) *NFTClassUpdateOne {
	if t != nil {
		ncuo.SetAcquireBookNftEventsLastProcessedTime(*t)
	}
	return ncuo
}

// ClearAcquireBookNftEventsLastProcessedTime clears the value of the "acquire_book_nft_events_last_processed_time" field.
func (ncuo *NFTClassUpdateOne) ClearAcquireBookNftEventsLastProcessedTime() *NFTClassUpdateOne {
	ncuo.mutation.ClearAcquireBookNftEventsLastProcessedTime()
	return ncuo
}

// SetAcquireBookNftEventsScore sets the "acquire_book_nft_events_score" field.
func (ncuo *NFTClassUpdateOne) SetAcquireBookNftEventsScore(f float64) *NFTClassUpdateOne {
	ncuo.mutation.ResetAcquireBookNftEventsScore()
	ncuo.mutation.SetAcquireBookNftEventsScore(f)
	return ncuo
}

// SetNillableAcquireBookNftEventsScore sets the "acquire_book_nft_events_score" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableAcquireBookNftEventsScore(f *float64) *NFTClassUpdateOne {
	if f != nil {
		ncuo.SetAcquireBookNftEventsScore(*f)
	}
	return ncuo
}

// AddAcquireBookNftEventsScore adds f to the "acquire_book_nft_events_score" field.
func (ncuo *NFTClassUpdateOne) AddAcquireBookNftEventsScore(f float64) *NFTClassUpdateOne {
	ncuo.mutation.AddAcquireBookNftEventsScore(f)
	return ncuo
}

// ClearAcquireBookNftEventsScore clears the value of the "acquire_book_nft_events_score" field.
func (ncuo *NFTClassUpdateOne) ClearAcquireBookNftEventsScore() *NFTClassUpdateOne {
	ncuo.mutation.ClearAcquireBookNftEventsScore()
	return ncuo
}

// SetAcquireBookNftEventsStatus sets the "acquire_book_nft_events_status" field.
func (ncuo *NFTClassUpdateOne) SetAcquireBookNftEventsStatus(nbnes nftclass.AcquireBookNftEventsStatus) *NFTClassUpdateOne {
	ncuo.mutation.SetAcquireBookNftEventsStatus(nbnes)
	return ncuo
}

// SetNillableAcquireBookNftEventsStatus sets the "acquire_book_nft_events_status" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableAcquireBookNftEventsStatus(nbnes *nftclass.AcquireBookNftEventsStatus) *NFTClassUpdateOne {
	if nbnes != nil {
		ncuo.SetAcquireBookNftEventsStatus(*nbnes)
	}
	return ncuo
}

// ClearAcquireBookNftEventsStatus clears the value of the "acquire_book_nft_events_status" field.
func (ncuo *NFTClassUpdateOne) ClearAcquireBookNftEventsStatus() *NFTClassUpdateOne {
	ncuo.mutation.ClearAcquireBookNftEventsStatus()
	return ncuo
}

// SetAcquireBookNftEventsFailedReason sets the "acquire_book_nft_events_failed_reason" field.
func (ncuo *NFTClassUpdateOne) SetAcquireBookNftEventsFailedReason(s string) *NFTClassUpdateOne {
	ncuo.mutation.SetAcquireBookNftEventsFailedReason(s)
	return ncuo
}

// SetNillableAcquireBookNftEventsFailedReason sets the "acquire_book_nft_events_failed_reason" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableAcquireBookNftEventsFailedReason(s *string) *NFTClassUpdateOne {
	if s != nil {
		ncuo.SetAcquireBookNftEventsFailedReason(*s)
	}
	return ncuo
}

// ClearAcquireBookNftEventsFailedReason clears the value of the "acquire_book_nft_events_failed_reason" field.
func (ncuo *NFTClassUpdateOne) ClearAcquireBookNftEventsFailedReason() *NFTClassUpdateOne {
	ncuo.mutation.ClearAcquireBookNftEventsFailedReason()
	return ncuo
}

// SetAcquireBookNftEventsFailedCount sets the "acquire_book_nft_events_failed_count" field.
func (ncuo *NFTClassUpdateOne) SetAcquireBookNftEventsFailedCount(i int) *NFTClassUpdateOne {
	ncuo.mutation.ResetAcquireBookNftEventsFailedCount()
	ncuo.mutation.SetAcquireBookNftEventsFailedCount(i)
	return ncuo
}

// SetNillableAcquireBookNftEventsFailedCount sets the "acquire_book_nft_events_failed_count" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableAcquireBookNftEventsFailedCount(i *int) *NFTClassUpdateOne {
	if i != nil {
		ncuo.SetAcquireBookNftEventsFailedCount(*i)
	}
	return ncuo
}

// AddAcquireBookNftEventsFailedCount adds i to the "acquire_book_nft_events_failed_count" field.
func (ncuo *NFTClassUpdateOne) AddAcquireBookNftEventsFailedCount(i int) *NFTClassUpdateOne {
	ncuo.mutation.AddAcquireBookNftEventsFailedCount(i)
	return ncuo
}

// SetAddress sets the "address" field.
func (ncuo *NFTClassUpdateOne) SetAddress(s string) *NFTClassUpdateOne {
	ncuo.mutation.SetAddress(s)
	return ncuo
}

// SetNillableAddress sets the "address" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableAddress(s *string) *NFTClassUpdateOne {
	if s != nil {
		ncuo.SetAddress(*s)
	}
	return ncuo
}

// SetName sets the "name" field.
func (ncuo *NFTClassUpdateOne) SetName(s string) *NFTClassUpdateOne {
	ncuo.mutation.SetName(s)
	return ncuo
}

// SetNillableName sets the "name" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableName(s *string) *NFTClassUpdateOne {
	if s != nil {
		ncuo.SetName(*s)
	}
	return ncuo
}

// SetSymbol sets the "symbol" field.
func (ncuo *NFTClassUpdateOne) SetSymbol(s string) *NFTClassUpdateOne {
	ncuo.mutation.SetSymbol(s)
	return ncuo
}

// SetNillableSymbol sets the "symbol" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableSymbol(s *string) *NFTClassUpdateOne {
	if s != nil {
		ncuo.SetSymbol(*s)
	}
	return ncuo
}

// SetOwnerAddress sets the "owner_address" field.
func (ncuo *NFTClassUpdateOne) SetOwnerAddress(s string) *NFTClassUpdateOne {
	ncuo.mutation.SetOwnerAddress(s)
	return ncuo
}

// SetNillableOwnerAddress sets the "owner_address" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableOwnerAddress(s *string) *NFTClassUpdateOne {
	if s != nil {
		ncuo.SetOwnerAddress(*s)
	}
	return ncuo
}

// ClearOwnerAddress clears the value of the "owner_address" field.
func (ncuo *NFTClassUpdateOne) ClearOwnerAddress() *NFTClassUpdateOne {
	ncuo.mutation.ClearOwnerAddress()
	return ncuo
}

// SetMinterAddresses sets the "minter_addresses" field.
func (ncuo *NFTClassUpdateOne) SetMinterAddresses(s []string) *NFTClassUpdateOne {
	ncuo.mutation.SetMinterAddresses(s)
	return ncuo
}

// AppendMinterAddresses appends s to the "minter_addresses" field.
func (ncuo *NFTClassUpdateOne) AppendMinterAddresses(s []string) *NFTClassUpdateOne {
	ncuo.mutation.AppendMinterAddresses(s)
	return ncuo
}

// ClearMinterAddresses clears the value of the "minter_addresses" field.
func (ncuo *NFTClassUpdateOne) ClearMinterAddresses() *NFTClassUpdateOne {
	ncuo.mutation.ClearMinterAddresses()
	return ncuo
}

// SetTotalSupply sets the "total_supply" field.
func (ncuo *NFTClassUpdateOne) SetTotalSupply(b *big.Int) *NFTClassUpdateOne {
	ncuo.mutation.SetTotalSupply(b)
	return ncuo
}

// SetMaxSupply sets the "max_supply" field.
func (ncuo *NFTClassUpdateOne) SetMaxSupply(t typeutil.Uint64) *NFTClassUpdateOne {
	ncuo.mutation.ResetMaxSupply()
	ncuo.mutation.SetMaxSupply(t)
	return ncuo
}

// SetNillableMaxSupply sets the "max_supply" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableMaxSupply(t *typeutil.Uint64) *NFTClassUpdateOne {
	if t != nil {
		ncuo.SetMaxSupply(*t)
	}
	return ncuo
}

// AddMaxSupply adds t to the "max_supply" field.
func (ncuo *NFTClassUpdateOne) AddMaxSupply(t typeutil.Uint64) *NFTClassUpdateOne {
	ncuo.mutation.AddMaxSupply(t)
	return ncuo
}

// SetMetadata sets the "metadata" field.
func (ncuo *NFTClassUpdateOne) SetMetadata(mlm *model.ContractLevelMetadata) *NFTClassUpdateOne {
	ncuo.mutation.SetMetadata(mlm)
	return ncuo
}

// ClearMetadata clears the value of the "metadata" field.
func (ncuo *NFTClassUpdateOne) ClearMetadata() *NFTClassUpdateOne {
	ncuo.mutation.ClearMetadata()
	return ncuo
}

// SetBannerImage sets the "banner_image" field.
func (ncuo *NFTClassUpdateOne) SetBannerImage(s string) *NFTClassUpdateOne {
	ncuo.mutation.SetBannerImage(s)
	return ncuo
}

// SetNillableBannerImage sets the "banner_image" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableBannerImage(s *string) *NFTClassUpdateOne {
	if s != nil {
		ncuo.SetBannerImage(*s)
	}
	return ncuo
}

// SetFeaturedImage sets the "featured_image" field.
func (ncuo *NFTClassUpdateOne) SetFeaturedImage(s string) *NFTClassUpdateOne {
	ncuo.mutation.SetFeaturedImage(s)
	return ncuo
}

// SetNillableFeaturedImage sets the "featured_image" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableFeaturedImage(s *string) *NFTClassUpdateOne {
	if s != nil {
		ncuo.SetFeaturedImage(*s)
	}
	return ncuo
}

// SetDeployerAddress sets the "deployer_address" field.
func (ncuo *NFTClassUpdateOne) SetDeployerAddress(s string) *NFTClassUpdateOne {
	ncuo.mutation.SetDeployerAddress(s)
	return ncuo
}

// SetNillableDeployerAddress sets the "deployer_address" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableDeployerAddress(s *string) *NFTClassUpdateOne {
	if s != nil {
		ncuo.SetDeployerAddress(*s)
	}
	return ncuo
}

// SetDeployedBlockNumber sets the "deployed_block_number" field.
func (ncuo *NFTClassUpdateOne) SetDeployedBlockNumber(t typeutil.Uint64) *NFTClassUpdateOne {
	ncuo.mutation.ResetDeployedBlockNumber()
	ncuo.mutation.SetDeployedBlockNumber(t)
	return ncuo
}

// SetNillableDeployedBlockNumber sets the "deployed_block_number" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableDeployedBlockNumber(t *typeutil.Uint64) *NFTClassUpdateOne {
	if t != nil {
		ncuo.SetDeployedBlockNumber(*t)
	}
	return ncuo
}

// AddDeployedBlockNumber adds t to the "deployed_block_number" field.
func (ncuo *NFTClassUpdateOne) AddDeployedBlockNumber(t typeutil.Uint64) *NFTClassUpdateOne {
	ncuo.mutation.AddDeployedBlockNumber(t)
	return ncuo
}

// SetLatestEventBlockNumber sets the "latest_event_block_number" field.
func (ncuo *NFTClassUpdateOne) SetLatestEventBlockNumber(t typeutil.Uint64) *NFTClassUpdateOne {
	ncuo.mutation.ResetLatestEventBlockNumber()
	ncuo.mutation.SetLatestEventBlockNumber(t)
	return ncuo
}

// SetNillableLatestEventBlockNumber sets the "latest_event_block_number" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableLatestEventBlockNumber(t *typeutil.Uint64) *NFTClassUpdateOne {
	if t != nil {
		ncuo.SetLatestEventBlockNumber(*t)
	}
	return ncuo
}

// AddLatestEventBlockNumber adds t to the "latest_event_block_number" field.
func (ncuo *NFTClassUpdateOne) AddLatestEventBlockNumber(t typeutil.Uint64) *NFTClassUpdateOne {
	ncuo.mutation.AddLatestEventBlockNumber(t)
	return ncuo
}

// SetDisabledForIndexing sets the "disabled_for_indexing" field.
func (ncuo *NFTClassUpdateOne) SetDisabledForIndexing(b bool) *NFTClassUpdateOne {
	ncuo.mutation.SetDisabledForIndexing(b)
	return ncuo
}

// SetNillableDisabledForIndexing sets the "disabled_for_indexing" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableDisabledForIndexing(b *bool) *NFTClassUpdateOne {
	if b != nil {
		ncuo.SetDisabledForIndexing(*b)
	}
	return ncuo
}

// SetDisabledForIndexingReason sets the "disabled_for_indexing_reason" field.
func (ncuo *NFTClassUpdateOne) SetDisabledForIndexingReason(s string) *NFTClassUpdateOne {
	ncuo.mutation.SetDisabledForIndexingReason(s)
	return ncuo
}

// SetNillableDisabledForIndexingReason sets the "disabled_for_indexing_reason" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableDisabledForIndexingReason(s *string) *NFTClassUpdateOne {
	if s != nil {
		ncuo.SetDisabledForIndexingReason(*s)
	}
	return ncuo
}

// ClearDisabledForIndexingReason clears the value of the "disabled_for_indexing_reason" field.
func (ncuo *NFTClassUpdateOne) ClearDisabledForIndexingReason() *NFTClassUpdateOne {
	ncuo.mutation.ClearDisabledForIndexingReason()
	return ncuo
}

// SetMintedAt sets the "minted_at" field.
func (ncuo *NFTClassUpdateOne) SetMintedAt(t time.Time) *NFTClassUpdateOne {
	ncuo.mutation.SetMintedAt(t)
	return ncuo
}

// SetNillableMintedAt sets the "minted_at" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableMintedAt(t *time.Time) *NFTClassUpdateOne {
	if t != nil {
		ncuo.SetMintedAt(*t)
	}
	return ncuo
}

// SetUpdatedAt sets the "updated_at" field.
func (ncuo *NFTClassUpdateOne) SetUpdatedAt(t time.Time) *NFTClassUpdateOne {
	ncuo.mutation.SetUpdatedAt(t)
	return ncuo
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableUpdatedAt(t *time.Time) *NFTClassUpdateOne {
	if t != nil {
		ncuo.SetUpdatedAt(*t)
	}
	return ncuo
}

// AddNftIDs adds the "nfts" edge to the NFT entity by IDs.
func (ncuo *NFTClassUpdateOne) AddNftIDs(ids ...int) *NFTClassUpdateOne {
	ncuo.mutation.AddNftIDs(ids...)
	return ncuo
}

// AddNfts adds the "nfts" edges to the NFT entity.
func (ncuo *NFTClassUpdateOne) AddNfts(n ...*NFT) *NFTClassUpdateOne {
	ids := make([]int, len(n))
	for i := range n {
		ids[i] = n[i].ID
	}
	return ncuo.AddNftIDs(ids...)
}

// SetOwnerID sets the "owner" edge to the Account entity by ID.
func (ncuo *NFTClassUpdateOne) SetOwnerID(id int) *NFTClassUpdateOne {
	ncuo.mutation.SetOwnerID(id)
	return ncuo
}

// SetNillableOwnerID sets the "owner" edge to the Account entity by ID if the given value is not nil.
func (ncuo *NFTClassUpdateOne) SetNillableOwnerID(id *int) *NFTClassUpdateOne {
	if id != nil {
		ncuo = ncuo.SetOwnerID(*id)
	}
	return ncuo
}

// SetOwner sets the "owner" edge to the Account entity.
func (ncuo *NFTClassUpdateOne) SetOwner(a *Account) *NFTClassUpdateOne {
	return ncuo.SetOwnerID(a.ID)
}

// Mutation returns the NFTClassMutation object of the builder.
func (ncuo *NFTClassUpdateOne) Mutation() *NFTClassMutation {
	return ncuo.mutation
}

// ClearNfts clears all "nfts" edges to the NFT entity.
func (ncuo *NFTClassUpdateOne) ClearNfts() *NFTClassUpdateOne {
	ncuo.mutation.ClearNfts()
	return ncuo
}

// RemoveNftIDs removes the "nfts" edge to NFT entities by IDs.
func (ncuo *NFTClassUpdateOne) RemoveNftIDs(ids ...int) *NFTClassUpdateOne {
	ncuo.mutation.RemoveNftIDs(ids...)
	return ncuo
}

// RemoveNfts removes "nfts" edges to NFT entities.
func (ncuo *NFTClassUpdateOne) RemoveNfts(n ...*NFT) *NFTClassUpdateOne {
	ids := make([]int, len(n))
	for i := range n {
		ids[i] = n[i].ID
	}
	return ncuo.RemoveNftIDs(ids...)
}

// ClearOwner clears the "owner" edge to the Account entity.
func (ncuo *NFTClassUpdateOne) ClearOwner() *NFTClassUpdateOne {
	ncuo.mutation.ClearOwner()
	return ncuo
}

// Where appends a list predicates to the NFTClassUpdate builder.
func (ncuo *NFTClassUpdateOne) Where(ps ...predicate.NFTClass) *NFTClassUpdateOne {
	ncuo.mutation.Where(ps...)
	return ncuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (ncuo *NFTClassUpdateOne) Select(field string, fields ...string) *NFTClassUpdateOne {
	ncuo.fields = append([]string{field}, fields...)
	return ncuo
}

// Save executes the query and returns the updated NFTClass entity.
func (ncuo *NFTClassUpdateOne) Save(ctx context.Context) (*NFTClass, error) {
	return withHooks(ctx, ncuo.sqlSave, ncuo.mutation, ncuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (ncuo *NFTClassUpdateOne) SaveX(ctx context.Context) *NFTClass {
	node, err := ncuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (ncuo *NFTClassUpdateOne) Exec(ctx context.Context) error {
	_, err := ncuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ncuo *NFTClassUpdateOne) ExecX(ctx context.Context) {
	if err := ncuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (ncuo *NFTClassUpdateOne) check() error {
	if v, ok := ncuo.mutation.AcquireBookNftEventsWeight(); ok {
		if err := nftclass.AcquireBookNftEventsWeightValidator(v); err != nil {
			return &ValidationError{Name: "acquire_book_nft_events_weight", err: fmt.Errorf(`ent: validator failed for field "NFTClass.acquire_book_nft_events_weight": %w`, err)}
		}
	}
	if v, ok := ncuo.mutation.AcquireBookNftEventsStatus(); ok {
		if err := nftclass.AcquireBookNftEventsStatusValidator(v); err != nil {
			return &ValidationError{Name: "acquire_book_nft_events_status", err: fmt.Errorf(`ent: validator failed for field "NFTClass.acquire_book_nft_events_status": %w`, err)}
		}
	}
	if v, ok := ncuo.mutation.Name(); ok {
		if err := nftclass.NameValidator(v); err != nil {
			return &ValidationError{Name: "name", err: fmt.Errorf(`ent: validator failed for field "NFTClass.name": %w`, err)}
		}
	}
	if v, ok := ncuo.mutation.Symbol(); ok {
		if err := nftclass.SymbolValidator(v); err != nil {
			return &ValidationError{Name: "symbol", err: fmt.Errorf(`ent: validator failed for field "NFTClass.symbol": %w`, err)}
		}
	}
	if v, ok := ncuo.mutation.DeployerAddress(); ok {
		if err := nftclass.DeployerAddressValidator(v); err != nil {
			return &ValidationError{Name: "deployer_address", err: fmt.Errorf(`ent: validator failed for field "NFTClass.deployer_address": %w`, err)}
		}
	}
	return nil
}

func (ncuo *NFTClassUpdateOne) sqlSave(ctx context.Context) (_node *NFTClass, err error) {
	if err := ncuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(nftclass.Table, nftclass.Columns, sqlgraph.NewFieldSpec(nftclass.FieldID, field.TypeInt))
	id, ok := ncuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "NFTClass.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := ncuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, nftclass.FieldID)
		for _, f := range fields {
			if !nftclass.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != nftclass.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := ncuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := ncuo.mutation.AcquireBookNftEventsWeight(); ok {
		_spec.SetField(nftclass.FieldAcquireBookNftEventsWeight, field.TypeFloat64, value)
	}
	if value, ok := ncuo.mutation.AddedAcquireBookNftEventsWeight(); ok {
		_spec.AddField(nftclass.FieldAcquireBookNftEventsWeight, field.TypeFloat64, value)
	}
	if value, ok := ncuo.mutation.AcquireBookNftEventsLastProcessedTime(); ok {
		_spec.SetField(nftclass.FieldAcquireBookNftEventsLastProcessedTime, field.TypeTime, value)
	}
	if ncuo.mutation.AcquireBookNftEventsLastProcessedTimeCleared() {
		_spec.ClearField(nftclass.FieldAcquireBookNftEventsLastProcessedTime, field.TypeTime)
	}
	if value, ok := ncuo.mutation.AcquireBookNftEventsScore(); ok {
		_spec.SetField(nftclass.FieldAcquireBookNftEventsScore, field.TypeFloat64, value)
	}
	if value, ok := ncuo.mutation.AddedAcquireBookNftEventsScore(); ok {
		_spec.AddField(nftclass.FieldAcquireBookNftEventsScore, field.TypeFloat64, value)
	}
	if ncuo.mutation.AcquireBookNftEventsScoreCleared() {
		_spec.ClearField(nftclass.FieldAcquireBookNftEventsScore, field.TypeFloat64)
	}
	if value, ok := ncuo.mutation.AcquireBookNftEventsStatus(); ok {
		_spec.SetField(nftclass.FieldAcquireBookNftEventsStatus, field.TypeEnum, value)
	}
	if ncuo.mutation.AcquireBookNftEventsStatusCleared() {
		_spec.ClearField(nftclass.FieldAcquireBookNftEventsStatus, field.TypeEnum)
	}
	if value, ok := ncuo.mutation.AcquireBookNftEventsFailedReason(); ok {
		_spec.SetField(nftclass.FieldAcquireBookNftEventsFailedReason, field.TypeString, value)
	}
	if ncuo.mutation.AcquireBookNftEventsFailedReasonCleared() {
		_spec.ClearField(nftclass.FieldAcquireBookNftEventsFailedReason, field.TypeString)
	}
	if value, ok := ncuo.mutation.AcquireBookNftEventsFailedCount(); ok {
		_spec.SetField(nftclass.FieldAcquireBookNftEventsFailedCount, field.TypeInt, value)
	}
	if value, ok := ncuo.mutation.AddedAcquireBookNftEventsFailedCount(); ok {
		_spec.AddField(nftclass.FieldAcquireBookNftEventsFailedCount, field.TypeInt, value)
	}
	if value, ok := ncuo.mutation.Address(); ok {
		_spec.SetField(nftclass.FieldAddress, field.TypeString, value)
	}
	if value, ok := ncuo.mutation.Name(); ok {
		_spec.SetField(nftclass.FieldName, field.TypeString, value)
	}
	if value, ok := ncuo.mutation.Symbol(); ok {
		_spec.SetField(nftclass.FieldSymbol, field.TypeString, value)
	}
	if value, ok := ncuo.mutation.OwnerAddress(); ok {
		_spec.SetField(nftclass.FieldOwnerAddress, field.TypeString, value)
	}
	if ncuo.mutation.OwnerAddressCleared() {
		_spec.ClearField(nftclass.FieldOwnerAddress, field.TypeString)
	}
	if value, ok := ncuo.mutation.MinterAddresses(); ok {
		_spec.SetField(nftclass.FieldMinterAddresses, field.TypeJSON, value)
	}
	if value, ok := ncuo.mutation.AppendedMinterAddresses(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, nftclass.FieldMinterAddresses, value)
		})
	}
	if ncuo.mutation.MinterAddressesCleared() {
		_spec.ClearField(nftclass.FieldMinterAddresses, field.TypeJSON)
	}
	if value, ok := ncuo.mutation.TotalSupply(); ok {
		vv, err := nftclass.ValueScanner.TotalSupply.Value(value)
		if err != nil {
			return nil, err
		}
		_spec.SetField(nftclass.FieldTotalSupply, field.TypeUint64, vv)
	}
	if value, ok := ncuo.mutation.MaxSupply(); ok {
		vv, err := nftclass.ValueScanner.MaxSupply.Value(value)
		if err != nil {
			return nil, err
		}
		_spec.SetField(nftclass.FieldMaxSupply, field.TypeUint64, vv)
	}
	if value, ok := ncuo.mutation.AddedMaxSupply(); ok {
		vv, err := nftclass.ValueScanner.MaxSupply.Value(value)
		if err != nil {
			return nil, err
		}
		_spec.AddField(nftclass.FieldMaxSupply, field.TypeUint64, vv)
	}
	if value, ok := ncuo.mutation.Metadata(); ok {
		_spec.SetField(nftclass.FieldMetadata, field.TypeJSON, value)
	}
	if ncuo.mutation.MetadataCleared() {
		_spec.ClearField(nftclass.FieldMetadata, field.TypeJSON)
	}
	if value, ok := ncuo.mutation.BannerImage(); ok {
		_spec.SetField(nftclass.FieldBannerImage, field.TypeString, value)
	}
	if value, ok := ncuo.mutation.FeaturedImage(); ok {
		_spec.SetField(nftclass.FieldFeaturedImage, field.TypeString, value)
	}
	if value, ok := ncuo.mutation.DeployerAddress(); ok {
		_spec.SetField(nftclass.FieldDeployerAddress, field.TypeString, value)
	}
	if value, ok := ncuo.mutation.DeployedBlockNumber(); ok {
		vv, err := nftclass.ValueScanner.DeployedBlockNumber.Value(value)
		if err != nil {
			return nil, err
		}
		_spec.SetField(nftclass.FieldDeployedBlockNumber, field.TypeUint64, vv)
	}
	if value, ok := ncuo.mutation.AddedDeployedBlockNumber(); ok {
		vv, err := nftclass.ValueScanner.DeployedBlockNumber.Value(value)
		if err != nil {
			return nil, err
		}
		_spec.AddField(nftclass.FieldDeployedBlockNumber, field.TypeUint64, vv)
	}
	if value, ok := ncuo.mutation.LatestEventBlockNumber(); ok {
		vv, err := nftclass.ValueScanner.LatestEventBlockNumber.Value(value)
		if err != nil {
			return nil, err
		}
		_spec.SetField(nftclass.FieldLatestEventBlockNumber, field.TypeUint64, vv)
	}
	if value, ok := ncuo.mutation.AddedLatestEventBlockNumber(); ok {
		vv, err := nftclass.ValueScanner.LatestEventBlockNumber.Value(value)
		if err != nil {
			return nil, err
		}
		_spec.AddField(nftclass.FieldLatestEventBlockNumber, field.TypeUint64, vv)
	}
	if value, ok := ncuo.mutation.DisabledForIndexing(); ok {
		_spec.SetField(nftclass.FieldDisabledForIndexing, field.TypeBool, value)
	}
	if value, ok := ncuo.mutation.DisabledForIndexingReason(); ok {
		_spec.SetField(nftclass.FieldDisabledForIndexingReason, field.TypeString, value)
	}
	if ncuo.mutation.DisabledForIndexingReasonCleared() {
		_spec.ClearField(nftclass.FieldDisabledForIndexingReason, field.TypeString)
	}
	if value, ok := ncuo.mutation.MintedAt(); ok {
		_spec.SetField(nftclass.FieldMintedAt, field.TypeTime, value)
	}
	if value, ok := ncuo.mutation.UpdatedAt(); ok {
		_spec.SetField(nftclass.FieldUpdatedAt, field.TypeTime, value)
	}
	if ncuo.mutation.NftsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   nftclass.NftsTable,
			Columns: []string{nftclass.NftsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(nft.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ncuo.mutation.RemovedNftsIDs(); len(nodes) > 0 && !ncuo.mutation.NftsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   nftclass.NftsTable,
			Columns: []string{nftclass.NftsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(nft.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ncuo.mutation.NftsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   nftclass.NftsTable,
			Columns: []string{nftclass.NftsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(nft.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ncuo.mutation.OwnerCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   nftclass.OwnerTable,
			Columns: []string{nftclass.OwnerColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(account.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ncuo.mutation.OwnerIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   nftclass.OwnerTable,
			Columns: []string{nftclass.OwnerColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(account.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &NFTClass{config: ncuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, ncuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{nftclass.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	ncuo.mutation.done = true
	return _node, nil
}
